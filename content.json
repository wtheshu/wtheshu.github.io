[{"title":"正则表达式实用技术","date":"2018-01-19T04:47:06.000Z","path":"2018/01/19/Linux/012. 正则表达式实用技术/","text":"GO 1. 正则表达式入门1.1. 定义正则表达式是处理字符串的方法，它是以行为单位来进行字符串的处理行为，通过一些特殊符号的辅助，可以轻易达到查找、删除、替换某特定字符的目的。它是一种规则，只要某工具支持正则表达式，便可以使用这种规则。（支持正则的工具有：vi、grep、awk、sed等） 注意： 使用正则表达式时，需要注意当时环境的语系是什么，否则结果会有所不同。 正则表达式的特殊字符与一般在命令行输入命令的通配符并不相同。 1.2. 特殊符号 特殊符号 代表意义 [:alnum:] 英文大小写字符及数字，即0-9，A-Z，a-z [:alpha:] 英文大小写字符，即A-Z，a-z [:lower:] 小写字母，即a-z [:upper:] 大写字母，即A-Z [:digit:] 数字，即0-9 [:blank:] 空格键与[Tab]按键 [:cntrl:] 键盘上面的控制按键，即包括CR，LF，Tab，Del等 [:graph:] 除了空格符（空格键与[Tab]按键）外的其它所有按键 [:print:] 任何可以被打印出来的字符 [:punct:] 标点符号（punctuation symbol），即” ‘ ? ! ; : # $ [:space:] 任何会产生空白的字符，包括空格键[Tab]CR等 [:xdigit:] 十六进制的数字类型，包括0-9，A-F，a-f的数字与字符 上表最常用的是前五个，要熟记！ 1.3. 基础正则表达式 RE字符 意义 ^word 待查找的字符串（word）在行首 word$ 待查找的字符串（word）在行尾 . 点 代表一定有一个任意字符的字符 \\ 转义字符，将特殊符号的特殊意义去除 *星号 重复零个到无穷多个的前一个字符 .* 表示任意个字符（包含空行） [list] 从字符集合的RE字符里找出想要选取的字符 [n1-n2] 从字符集合的RE字符里面找出想要选取的字符范围 [^list] 从字符集合的RE字符里面找出不要的字符串或范围 {n,m} 连续n到m的前一个RE字符，若为{n}则是连续n个前一个RE字符，若为{n,}则是连续n个以上的前一个RE字符 1.4. 扩展正则表达式 RE字符 意义 + 重复一个或一个以上的前一个RE字符 ? 零个或一个的前一个RE字符 “竖杠” 用或（or）的方式找出数个字符串 () 找出 “组”字符串 ()+ 多个重复组的判别 1.5. 注意 {}、+、-、|等在grep中使用时需要加反斜杠脱义，而在egrep直接使用即可。 egrep 和 grep -E 的效果是一样的。 sed -r 是使用扩展正则表达式的参数。 2. 支持正则的常用工具 2.1. grep 和 egrep2.1.1. grepgrep是以行为单位，在数据中进行字符串对比，并打印出所匹配到的字符串及其整行内容。 常用参数 参数说明 -A 后面可加数字，为after之意，列出匹配到的行及后面的n行 -B 后面可加数字，为before之意，列出匹配到的行及前面的n行 -C 综合-A和-B的功能 -n 显示出所匹配到的行的行号 -v 反向匹配 -i 忽略字母的大小写 -c 打印符合要求的行的个数 -o 打印符合要求的关键字出现的字数 -r 会把目录下面所有的文件全部遍历（该目录下的子目录下的文件也会遍历） –color=auto 自动加上颜色显示出关键字 2.1.2. egrepgrep 和 grep -E 是别名的关系，是grep使用扩展正则表达式要用的参数。grep默认只支持基础正则表达式，所以，当使用到扩展正则表达式的时候，就要用这个命令. 2.1.3. 一些例子 过滤出带有某个关键词的行并输出行号 grep -n &#39;root&#39; 1.txt 过滤出不带有某个关键字的行并输出行号 grep -n -v &#39;root; 1.txt 过滤出所有包含数字的行 grep &#39;[0-9]&#39; 1.txt 过滤出所有不包含数字的行 grep -v &#39;[0-9]&#39; 1.txt 去除所有以‘#’开头的行 grep -v &#39;^#&#39; 1.txt 去除所有空行和以‘#’开头的行 grep -v &#39;^$&#39; 1.txt | grep -v &#39;^#&#39; 过滤出以英文字母开头的行 grep &#39;^[a-zA-Z]&#39; 1.txt 过滤出以非数字开头的行 grep &#39;^[^0-9]&#39; 1.txt 过滤任意一个或多个字符 grep &#39;r.o&#39; 1.txt ； grep &#39;r*t&#39; 1.txt ； grep &#39;r.*p&#39; 1.txt . 表示任意一个字符 * 表示零个或多个*前面的字符 .* 表示零个或多个任意字符，空行也包含在内 grep -E &#39;ro?t&#39; 1.txt ？表示匹配零个或一个?前面的字符 grep -E &#39;ro+t&#39; 1.txt +表示匹配一个或多个+前面的字符 指定过滤字符次数 grep &#39;o\\{2\\}&#39; 1.txt egrep &#39;o+&#39; 1.txt 表示1个或多个前面的字符 egrep &#39;o?&#39; 1.txt 表示0个或1个前面的字符 egrep &#39;roo|body&#39; 1.txt 匹配roo或者匹配body（grep ‘roo\\|body’ 1.txt 也可以实现这个功能，即用转义符把|转义） egrep &#39;r(oo)|(at)o&#39; 1.txt 用括号表示一个整体 egrep &#39;(oo)+&#39; 1.txt 表示匹配1个或多个‘oo’ egrep &#39;(oo){2}&#39; 1.txt 表示匹配有两次’oo’ egrep &#39;(oo){1,2}&#39; 1.txt 表示匹配有一次或两次’oo’ 2.2. sed2.2.1. sed 的用法sed是一个很好的文件处理工具，本事是一个管道命令，主要是以行为单位进行处理，可以将数据进行替换、删除、新增、选取等特定工作。sed的用法如下： sed的命令行格式为 sed [-nefri] &#39;command&#39; 输入文本 2.2.2. sed 常用选项 选项 意义 -n 使用安静（silent）模式。在一般的sed的用法中，所有来自stdin的数据都会被列到屏幕上。但如果加上-n选项后，则只有经过sed特殊处理的那一行（或者动作）才会被列出来。 -e 直接在命令行模式上进行sed的动作编辑 -f 直接将sed的动作写在一个文件内，-f filename 则可以执行filename内的sed动作 -r sed在使用扩展正则表达式需要加的参数（默认是基础正则表达式的使用） -i 直接修改读取的文件内容，而不是仅仅显示在屏幕上 2.2.3. sed 常用命令 命令 意义 a 新增，a的后面可以接字符串，而这些字符串会在新的一行出现（当前的下一行） c 取代，c的后面可以接字符串，而这些字符串可以取代n1,n2之间的行 d 删除，因为是删除操作，所以d后面通常不接任何东西 i 插入，i的后面可以接字符串，而这些字符串会在新的一行出现（当前的上一行） p 打印，即将某个选择的数据打印出来。通常p会与参数 sed -n 一起使用 s 替换，可以直接进行替换的工作。通常这个s的动作可以搭配正则表达式。例如 1,20s/old/new/g 2.2.4. sed 一些常用例子1. 打印指定行 打印第10行：sed -n &#39;10p&#39; 1.txt 打印1到4行：sed -n &#39;1,4p&#39; 1.txt 打印5行到最后：sed -n &#39;5,$p&#39; 1.txt 2. 打印包含某个字符串的行 打印出包含root的行：sed -n &#39;/root/p&#39; 1.txt 可以使用正则表达式中的符号，例如^、.、*、$等，-r选项是使用扩展正则表达式时要加的选项（默认是基础正则表达式的使用） 3. -e 可以实现同时进行多个任务的选项 sed -e &#39;/root/p&#39; -e &#39;/body/p&#39; -n 1.txt 匹配root和body的行，如果一行中有root和body，则该行会被打印两次 也可以用分号;实现：sed &#39;/root/p ; /body/p&#39; -n 1.txt 功能同上 4. 删除行 删除包含root的行：sed &#39;/root/d&#39; 1.txt 删除第一行，其它行显示：sed &#39;1d&#39; 1.txt 删除1到10行，其它行显示：sed &#39;1,10d&#39; 1.txt 5. 替换 sed &#39;1,2s/ot/to/g&#39; 1.txt 其中的s就是替换的意思，g为全局替换，否则只替换本行中出现的第一个，/分隔符也可以用#、@等符号 删除所有数字：sed &#39;s/[0-9]//g&#39; 1.txt 删除所有非数字：sed &#39;s/[^0-9]//g&#39; 1.txt 调换两个字符串的位置：head -n2 1.txt | sed &#39;s/\\(root\\)\\(.*\\)\\(bash\\)/\\3\\2\\1/&#39; 或 head -n2 1.txt | sed -r &#39;s/(root)(.*)(bash)/\\3\\2\\1/&#39; 直接修改文件内容：sed -i &#39;s/ot/to/g&#39; 1.txt 2.2.5. sed 练习题和答案 把/etc/passwd 复制到 /root/test.txt，用sed打印所有行：/bin/cp /etc/passwd /root/test.txt ; sed -n &#39;1,$p&#39; test.txt 打印test.txt的3到10行：sed -n &#39;3,10p&#39; test.txt 打印test.txt中包含root的行：sed -n &#39;/root/p&#39; test.txt 删除test.txt的15行以及以后所有行：sed &#39;15,$d&#39; test.txt 删除test.txt中包含bash的行：sed &#39;/bash/d&#39; test.txt 替换test.txt 中’root’为’toor’：sed &#39;s/root/toor/g&#39; test.txt 替换text.txt中/sbin/nologin为/bin/login：sed &#39;s#sbin/login#bin/login#g&#39; test.txt 删除test.txt中5到10行所有的数字：sed &#39;5,10s/[0-9]//g&#39; test.txt 删除test.txt中所有的特殊字符（除了数字以及大小写字母）：sed &#39;s/[^0-9a-zA-Z]//g&#39; test.txt 把test.txt中第一个单词和最后一个单词调换位置：sed -r &#39;s/(^[a-zA-Z]+)([^a-zA-Z].*[^a-zA-Z])([a-zA-Z]+$)/\\3\\2\\1/&#39; test.txt 把test.txt中出现的第一个数字和最后一个单词调换位置：sed -r &#39;s/(^[^0-9]*)([0-9]+)([^0-9].*[^a-zA-Z]+$)/\\1\\4\\3\\2/&#39; test.txt 把test.txt中第一个数字移动到行末尾：sed -r &#39;s/(^[^0-9]*)(^[0-9]+)([^0-9].*$)/\\1\\3\\2/&#39; test.txt 在test.txt中20行到末行最前面加”aaa:”：sed &#39;20,$s/^.*$/aaa:&amp;/&#39; test.txt 2.2.6. sed 学习说明sed的常用功能基本上都在上面，这些就足够日常运维工作的使用了，若是遇到复杂的需求，再去查一下资料即可。 2.3. awkawk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说，awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk有3个不同版本：awk、nawk和gawk，未作特别说明，一般指gawk，gawk是awk的GNU版本。 awk其名称得自于它的创始人 Alfred Aho、Peter Weinberger和Brian Kernighan 姓氏的首个字母。实际上AWK的确拥有自己的语言：AWK程序设计语言，三位创建组已将它正式定义为”样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 2.3.1. awk 初学笔记1. awk的用法awk和sed一样，都是流式编辑器，针对文档中的行来操作，一行一行地执行。awk兼具sed的所有功能，而且更加强大。awk工具其实是很复杂的（有专门的书来介绍它的应用），对于初学者来说，只要能处理日常管理工作中的问题即可。鉴于此，下面的内容仅仅介绍了比较常见的awk应用。 - 截取文档中的某个段 截取文档中的某个段 awk -F&#39;:&#39; &#39;{print $1}&#39; 1.txt 本例中，-F选项的作用是指定分隔符。若不加-F选项，则以空格或者tab为分隔符。print为打印的动作，用来打印某个字段。$1为第一个字段，$2为第2个字段，以此类推。但是$0比较特殊，它表示整行。awk -F&#39;:&#39; &#39;{print $0}&#39; 1.txt 注意awk的格式，-F后面紧跟单引号，单引号里面为分隔符。print的动作要用{}括起来，否则会报错。 print也可以打印自定义的内容，但是自定义的内容要用双引号括起来 awk -F&#39;:&#39; &#39;{print $1&quot;#&quot;$2&quot;#&quot;$3&quot;#&quot;$4}&#39; 1.txt - 匹配字符或者字符串 匹配字符或字符串 awk &#39;/oo/&#39; 1.txt 这种用法跟sed的用法类似，能实现grep的功能，但没有颜色显示，也不如grep用起来方便。 可针对某个段匹配 awk -F&#39;:&#39; &#39;$1~/oo/&#39; 1.txt 这里的~就是匹配的意思。 多次匹配 awk -F&#39;:&#39; &#39;/root/ {print $1,$3}; $1~/test/; $3~/20/&#39; 1.txt - 条件操作符awk中可以用逻辑符号进行判断，比如==就是等于，也可以理解为精确匹配。另外还有&gt;、&gt;=、&lt;、&lt;=、!=等。值得注意的是，在和数字比较时，若把比较的数字用双引号括起来，那么awk不会认为是数字，而会认为是字符，不加双引号会认为是数字。 条件操作符 ==,&gt;,&lt;,!=,&gt;=,&lt;= awk -F&#39;:&#39; &#39;$3==&quot;0&quot;&#39; 1.txt awk -F&#39;:&#39; &#39;$3&gt;=&quot;500&quot;&#39; 1.txt awk -F&#39;:&#39; &#39;$7!=&quot;/sbin/mologin&quot;&#39; 1.txt awk -F&#39;:&#39; &#39;$3&lt;$4&#39; 1.txt awk -F&#39;:&#39; &#39;$3&gt;&quot;5&quot; &amp;&amp; $3&lt;&quot;7&quot;&#39; 1.txt 另外还可以使用&amp;&amp;和||，它们分别表示”并且”和”或者”。 awk -F&#39;:&#39; &#39;$3&gt;&quot;5&quot; &amp;&amp; $7==&quot;/bin/bash&quot;&#39; 1.txt awk -F&#39;:&#39; &#39;$3&gt;&quot;5&quot; || $7==&quot;/bin/bash&quot;&#39; 1.txt - awk的内置变量awk的常用内置变量有OFS、NF和NR。OFS和-F选项有类似的功能，也是用来定义分隔符的，但是它是在输出的时候定义；NF表示用分隔符分隔后一共有多少段，NR表示行号。 OFS的用法： awk -F&#39;:&#39; &#39;{OFS=&quot;#&quot;} {print $1,$3,$4}&#39; 1.txt awk -F&#39;:&#39; &#39;{OFS=&#39;#&#39;} {if ($3&gt;1000) {print $1,$2,$3,$4}}&#39; 1.txt NF的具体用法： head -n3 1.txt | awk -F &#39;:&#39; &#39;{print NF}&#39; head -n3 1.txt | awk -F &#39;:&#39; &#39;{print $NF}&#39; 这里NF是多少段，$NF是最后 一段的值。 NR的用法： head -n3 1.txt | awk -F &#39;:&#39; &#39;{print NR}&#39; 还可以用NR作为判断条件，比如打印20行以后的行 awk &#39;NR&gt;20&#39; 1.txt NR也可以和段匹配一起使用，如 awk -F &#39;:&#39; &#39;NR&gt;20 &amp;&amp; $1 ~/ssh/&#39; 1.txt - awk中的数学运算 awk可以更改段值 awk -F &#39;:&#39; &#39;$1=&quot;root&quot;&#39; 1.txt 也可以对各个段的值进行数学运算，例如把第三段和第四段的值相加并赋予第七段 awk -F &#39;:&#39; &#39;{$7=$3+$4;print $0}&#39; 1.txt 计算第三段的总和 awk -F &#39;:&#39; ‘{(tot=toy+$3)};END {print tot}’ 1.txt awk中也可以使用if 关键词 awk -F &#39;:&#39; &#39;{if ($1==&quot;root&quot;) print $0}&#39; 1.txt ~~~说明：以上介绍的内容仅仅是最基本的内容，这些东西完全可以满足日常工作的需求。若是遇到比较复杂的需求，再去查阅资料学习更深的东西。 2. awk练习题题目： 用awk打印整个test.txt。（以下操作都是针对test.txt的，用awk工具实现） 查找所有包含bash的行。 用:作为分隔符，查找第3个字段等于o的行。 用:作为分隔符，查找第1个字段为root的行，并把该段的root换成toor。（可以连同sed一起使用） 用:作为分隔符，打印最后一个字段。 打印行数大于20的所有行。 用:作为分隔符，打印所有第3个字段小于第4个字段的行。 用:作为分隔符，打印第1个字段以及最后一个字段，并且中间用@连接（例如，第1行应该是这样的形式：root@/bin/bash） 用:作为分隔符，把整个文档的第4个字段相加，求和。 答案： awk &#39;{print $0}&#39; test.txt awk &#39;/bash/&#39; test.txt awk -F&#39;:&#39; &#39;$3==&quot;o&quot;&#39; test.txt awk -F&#39;:&#39; &#39;$1==&quot;root&quot;&#39; test.txt | sed &#39;s/root/toor/&#39; awk -F&#39;:&#39; &#39;{print $NF}&#39; test.txt awk -F&#39;:&#39; &#39;NR&gt;20&#39; test.txt awk -F&#39;:&#39; &#39;$3&lt;$4&#39; test.txt awk -F&#39;:&#39; &#39;{print $1&quot;@&quot;$NF}&#39; test.txt awk -F&#39;:&#39; &#39;{(sum+=$4)}; END {print sum}&#39; test.txt 2.3.2. awk 入门笔记1. 使用方法使用格式为 : awk &#39;{pattern + action}&#39; {filename} 尽管操作可能会很复杂，但语法总是这样，其中pattern表示awk在数据中查找的内容，而action是在找到匹配内容时所执行的一系列命令。花括号（{ }）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。pattern就是要表示的正则表达式，用斜杠括起来。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其它文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 2. 调用awk的三种方式- 命令行方式格式：awk [-F field-separator] &#39;conmmands&#39; input-file(s)其中，commands是真正awk命令，[-F域分隔符]是可选的。input-file(s)是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指定-F域分隔符的情况下，默认的域分隔符是空格。 - shell脚本方式将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。相当于shell脚本首行的：#!/bin/sh可以换成：#!/bin/awk - 将所有的awk命令插入一个单独文件，然后调用格式 awk -f awk-script-file input-file(s)其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。 在这里，主要用的是第一种方式：命令行方式。 3. 入门实例假设last -n 5的输出如下：123456[root@www ~]# last -n 5 &lt;==仅取出前五行root pts/1 192.168.1.100 Tue Feb 10 11:21 still logged inroot pts/1 192.168.1.100 Tue Feb 10 00:46 - 02:28 (01:41)root pts/1 192.168.1.100 Mon Feb 9 11:41 - 18:30 (06:48)dmtsai pts/1 192.168.1.100 Mon Feb 9 11:41 - 11:41 (00:00)root tty1 Fri Sep 5 14:09 - 14:10 (00:01) 示例1如果只是显示最近登陆的5个账号123456#last -n 5 | awk '&#123;print $1&#125;'rootrootrootdmtsairoot awk工作流程是这样的：读入有’\\n’换行符分割的一条记录，然后将记录按照指定的域分隔符划分域，填充域，$0则表示所有域，$1表示第一个域，$n表示第n个域。默认域分割符是”空白键”或”[tab]键”，所以$1表示登陆用户，$3表示登陆用户ip，以此类推。 示例2如果只是显示/etc/passwd的账户12345#cat /etc/passwd |awk -F ':' '&#123;print $1&#125;' rootdaemonbinsys 这种是awk+action的示例，每行都会执行action{print $1}。-F指定域分隔符为’:’。 示例3如果只是显示/etc/passwd的账户和账户对应的shell，而账户与shell之间以tab键分割12345#cat /etc/passwd |awk -F ':' '&#123;print $1\"\\t\"$7&#125;'root /bin/bashdaemon /bin/shbin /bin/shsys /bin/sh 示例4如果只是显示/etc/passwd的账户和账户对应的shell，而账户与shell之间以逗号分割，而且在所有行添加列明name,shell，在最后一行添加blue,/bin/nosh12345678cat /etc/passwd |awk -F ':' 'BEGIN &#123;print \"name,shell\"&#125; &#123;print $1\",\"$7&#125; END &#123;print \"blue,/bin/nosh\"&#125;'name,shellroot,/bin/bashdaemon,/bin/shbin,/bin/shsys,/bin/sh....blue,/bin/nosh awk的工作流程是这样的：先执行BEGiNG，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分割符划分域，填充域，$0则表示所有域，$1表示第一个域，$n表示第n个域，随后开始执行模式所对应的动作action。接着开始读入第二条记录……知道所有的记录都读完，最后执行END操作。 示例5搜索/etc/passwd有root关键字的所有行12#awk -F: '/root/' /etc/passwdroot:x:0:0:root:/root:/bin/bash 这种是pattern的使用示例，匹配了pattern（这里是root）的行才会执行action（没有指定action，默认输出每行的内容）。搜索支持正则，例如找root开头的：awk -F: &#39;/^root/&#39; /etc/passwd 示例6搜索/etc/passwd有root关键字的所有行，并显示对应的shell12# awk -F: '/root/&#123;print $7&#125;' /etc/passwd /bin/bash 这里指定了action{print $7} 4. awk 内置变量awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。 变量名 值的意义 ARGC 命令行参数个数 ARGV 命令行参数排列 ENVIRON 支持队列中系统环境变量的使用 FILENAME awk浏览的文件名 FNR 浏览文件的记录数 FS 设置输入域分隔符，等价于命令行 -F 选项 NF 浏览记录的域的个数 NR 已读的记录数 OFS 输出域分隔符 ORS 输出记录分隔符 RS 控制记录分隔符 $0 整条记录 $1 当前行的第一个域 $n 当前行的第n个域 示例如下： 统计/etc/passwd的文件名，每行的行号，每行的列数，对应的完整行内容：12345#awk -F ':' '&#123;print \"filename:\" FILENAME \",linenumber:\" NR \",columns:\" NF \",linecontent:\"$0&#125;' /etc/passwdfilename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bashfilename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/shfilename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/shfilename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh 使用printf替代print，可以让代码更加简洁、易读：1awk -F ':' '&#123;printf(\"filename:%10s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)&#125;' /etc/passwd 5. print 和 printfawk中同时提供了print和printf两种打印输出的函数。 其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。 printf函数，其用法和C语言中printf基本相似，可以格式化字符串，输出复杂时，printf更加好用，代码更易懂。 6. awk编程变量和赋值除了awk的内置变量，awk还可以自定义变量。 下面统计/etc/passwd的账户人数1234awk '&#123;count++;print $0;&#125; END&#123;print \"user count is \", count&#125;' /etc/passwdroot:x:0:0:root:/root:/bin/bash......user count is 40 count是自定义变量。之前的action{}里都是只有一个print，其实print只是一个语句，而action{}可以有多个语句，以;号隔开。 上面的用法里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0：12345awk 'BEGIN &#123;count=0;print \"[start]user count is \", count&#125; &#123;count=count+1;print $0;&#125; END&#123;print \"[end]user count is \", count&#125;' /etc/passwd[start]user count is 0root:x:0:0:root:/root:/bin/bash...[end]user count is 40 统计某个目录下的文件占用的字节数12ls -l |awk 'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \", size&#125;'[end]size is 8657198 如果以M为单位显示：12ls -l |awk 'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \", size/1024/1024,\"M\"&#125;'[end]size is 8.25889 M 注意，统计不包括目录的子目录。 条件语句awk中的条件语句是从C语言中借鉴而来的，见如下声明方式：12345678910111213141516171819if (expression) &#123; statement; statement; ... ...&#125;if (expression) &#123; statement;&#125; else &#123; statement2;&#125;if (expression) &#123; statement1;&#125; else if (expression1) &#123; statement2;&#125; else &#123; statement3;&#125; 统计某个目录下的文件占用的字节数，过滤4096大小的文件（一般都是目录）12ls -l |awk 'BEGIN &#123;size=0;print \"[start]size is \", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print \"[end]size is \", size/1024/1024,\"M\"&#125;' [end]size is 8.22339 M 循环语句awk中的循环语句同样借鉴于C语言，支持while、do-while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。 数组因为awk中数组的下表可以是数字和字母，数字的下标通常被称为关键字（key）。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。 显示/etc/passwd的账户12345678awk -F ':' 'BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;' /etc/passwd0 root1 daemon2 bin3 sys4 sync5 games...... 这里使用for循环遍历数组。 2.3.3. awk 学习说明以上便是awk最常用的使用方法。但如果想深学awk编程，请参考专业书籍。 OK","tags":[]},{"title":"Linux计划任务管理技术","date":"2018-01-19T01:05:17.000Z","path":"2018/01/19/Linux/011. Linux计划任务管理技术/","text":"GO 0. 计划任务服务程序Linux系统的计划任务分为三种： 一次性计划任务（用at命令实现，由atd服务提供） 周期性计划任务（用crontab命令实现，由crond服务提供） 系统级别的计划任务及其扩展anacron：在一个指定时间间隔错过后自动执行任务 1. 一次性计划任务1.1. at 命令一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用at命令来实现这种功能。用法如下： at 时间 ：添加一次性计划任务 at -l ：查看已设置好但还未执行的一次性计划任务 atrm 任务序号 ：删除一条一次性计划任务（还可以进入到/var/spool/at目录里把计划任务删除，计划任务的文件都保存在该目录里，可以用rm -f 文件名来删除(以文件的形式删除计划任务，因为计划任务是以文件形式保存在该目录中)） 1.2. 关于at的说明在通常情况下，超级用户都可以使用这个命令。对于其他用户来说，能否可以使用就取决于两个文件：/etc/at.allow 和 /etc /at.deny。 如果你要让哪个用户不能使用计划任务，就直接把他的用户名写进去就可以了，一排只能写一个。 同时写入allow 及deny, 允许。 1.2. at的使用示例在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系统设置为在今晚23：30分自动重启网站服务：123456[root@theshuhost ~]# at 23:30at&gt; systemctl restart httpdat&gt; &lt;EOT&gt; # 此处请同时按下Ctrl + D组合键来结束编写计划任务job 1 at Fri Jan 19 23:30:00 2018[root@theshuhost ~]# at -l1 Fri Jan 19 23:30:00 2018 a root 也可以利用管道符来达到非交互式的方式创建一次性计划任务的目的：12345[root@theshuhost ~]# echo \"systemctl restart httpd\" | at 23:40job 2 at Fri Jan 19 23:40:00 2018[root@theshuhost ~]# at -l1 Fri Jan 19 23:30:00 2018 a root2 Fri Jan 19 23:40:00 2018 a root 如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个：123456[root@theshuhost ~]# at -l1 Fri Jan 19 23:30:00 2018 a root2 Fri Jan 19 23:40:00 2018 a root[root@theshuhost ~]# atrm 2[root@theshuhost ~]# at -l1 Fri Jan 19 23:30:00 2018 a root 2. 周期性计划任务相对与at，cron的优点就是能够周期性的执行某个命令,at却只能执行一次。 cron的后台进程名字是crond ,cron也是system V的服务，所以我们可以service crond start|stop 来启动和关闭此服务,也可以使用chkconfig或者ntsysv来选择cron服务的默认开启。 2.1. crontab 命令Linux的周期性任务计划功能的操作都是通过这个crontab命令来完成的。常用的选项有： -u：指定某个用户，不加-u选项则为当前用户 -e：制定计划任务 -l：列出计划任务(也可以到/var/spool/cron/目录查看。里面的文件名字就是对应用户的cron任务) -r：删除当前用户的计划任务 在配置文件/etc/crontab中可以查看计划任务配置的规则：123456789101112SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 以一个例子来说明其设置的格式： crontab -e 回车后输入如下内容： 01 10 05 06 3 echo &quot;ok&quot; &gt; /root/cron.log 这样就增加了一条计划任务，关于计划任务内容的说明如下： 每个字段的数字分别表示（从左到右）：分、时、日、月、周、命令。 上一个例子的含义是：在6月5日（这一天必须是星期三）的10点01分执行命令echo “ok” &gt; /root/cron.log。 crontab -e命令实际上是打开了配置文件/var/spool/cron/username（如果是root用户，则打开的是/var/spool/cron/root）,所使用的编辑器是vi，所以要保存的话则需要在命令模式下输入”:/wq”即可。 注意：千万不要直接去编辑那个文件，因为可能会出错，所以一定要使用命令crontab -e来编辑。 使用该命令的其他常用用法： crontab -l ：查看已经设定的任务计划 crontab -r ：删除任务计划 2.2. 一个问题的说明vim /etc/crontab 与crontab -e写入的定时运行有什么区别? vim /etc/crontab：是系统级别定义的crontab，/etc/crontab的所有者和组都是root crontab -e ：是用户自定义的crontab，是所有的用户都可以写入的 两种方法记录的位置不一样，一个在/etc/ 另一个在/var/ 里面。都被cron服务调用 2.3. 关于任务计划的练习题目如下： 每天凌晨1点20分清除/var/log/slow.log这个文件 每周日3点执行”/bin/sh /usr/local/sbin/backup.sh” 每月14号4点10分执行”/bin/sh /usr/local/sbin/backup_month.sh” 每隔8小时执行”ntpdate time.windows.com” 每天的1点、12点、18点执行”/bin/sh /usr/local/sbin/test.sh” 每天的9点到18点执行”/bin/sh /usr/local/sbin/test2.sh” 答案如下： 20 1 * * * echo &quot;&quot; &gt; /var/lpg/slow.log 0 3 * * 0 /bin/sh /usr/local/sbin/backup.sh 10 4 14 * * /bin/sh /usr/local/sbin/backup_month.sh 0 */8 * * * ntpdate time.windows.com 0 1,12,18 * * /bin/sh /usr/local/sbin/test.sh 0 9-18 * * * /bin/sh /usr/local/sbin/test2.sh 说明： 每隔8小时，就是用全部小时（0-23）去除以8,其实算出来应该是0、8、16三个数。 当遇到多个数（分钟、小时、月、周）例如第5题，则需要用都好隔开。 而时间段是可以用n-m的方式表示的，比如第6题中的9-18 在设置好所有的计划任务后需要查看一下crond服务是否启动：service crond status 3. 系统级别的计划任务及其扩展anacronanacrontab就是系统计划任务的扩展文件：在一个指定时间间隔错过后自动执行任务。 这个是系统设置好了，清理系统垃圾或者是自动执行某些脚本的系统任务，一般我们做了解就行了，不要更改。 配置文件是/etc/anaconrtab123456789# /etc/anacrontab: configuration file for anacron# See anacron(8) and anacrontab(5) for details.SHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root#####格式是这样的：period(频率.天数) delay(延迟,分钟) job- identifier command1 65 cron.daily run-parts /etc/cron.daily7 70 cron.weekly run-parts /etc/cron.weekly30 75 cron.monthly run-parts /etc/cron.monthly 说明： SHELL：就是运行计划任务的解释器，默认是bash PATH：执行命令的环境变量 MAILTO：计划任务的出发者用户 HOME：家目录为/ run-parts是一个脚本，在/usr/bin/run-parts，作用是执行一个目录下的所有脚本/程序。 run-parts /etc/cron.hourly执行目录/etc/cron.hourly/之下的所有脚本/程序. run-parts下面就是运行的命令 第一行的意思是：每天开机65分钟后就检查cron.daily文件是否被执行了，如果今天没有被执行就执行它 第二行的意思是：每隔7天开机后70分钟检查cron.weekly文件是否被执行了,如果一周内没有被执行就执行它 和at差不多，就是/etc/cron.deny这个配置文件来控制, 同时写入allow 及deny, 允许. OK","tags":[]},{"title":"《Vim实用技巧》-开始：Vim解决问题的方式","date":"2017-12-29T07:56:24.000Z","path":"2017/12/29/Tool/007. 《Vim实用技巧》-开始：Vim解决问题的方式/","text":"GO 技巧1 结识 . 命令理想的编辑模式：用一次按键移动，用另一次按键执行。 . 命令可以重复上次修改。 上次修改 可以指很多东西，一次修改的单位可以是字符、整行，甚至是整个文件。 每次进入插入模式时，也会形成一次修改。从进入插入模式的那一刻起（例如，输入i），直到返回普通模式时为止（输入 Esc ）,Vim 会记录每一个按键操作。做出这样一个修改后再用 . 命令，就会重新执行所有的这些按键操作。 补充内容 x 命令会删除光标下的字符 dd 命令会删除光标所在的一整行 &gt;G 命令会增加从当前行到文档末尾处的缩进层级 技巧2 不要自我重复对于在行尾添加内容这样的常见操作，如添加分号，Vim 提供了一个专门的命令，可以把两步操作合并为一步。 减少无关紧要的移动。以下面的一个例子来说明： a 命令在当前光标后添加内容，而 A 命令则在当前行的结尾添加内容。不管光标当前处于什么位置，输入 A 都会进入插入模式，并把光标移动行尾。换句话说，它把 $a 封装成了一个按键操作。 很多Vim的单键命令都可以被看成两个或多个其他命令的组合。下表列出了类似的一些例子： 复合命令 等效的长命令 C c$ s cl S ^c A $a o A O ko 上表所示这些命令的共同点是，它们全都会从普通模式切换到插入模式。 补充内容 $ 命令把光标移到行尾 j 命令使光标下移一行 技巧3 以退为进我们可以用一种常用的 Vim 操作习惯在一个字符前后各添加一个空格。乍一看，这种方法有点古怪，不过其好处是可重复，这将使我们可以事半功倍地完成工作 先后退一步或多步，然后前进一步或多步，这是个奇怪的小花招，看起来可能不够直接。但这样做最大的好处是：我们可以用 . 命令重复这一修改。 与其和 Vim 区分模式的编辑模型做斗争，倒不如与它一起协同工作。然后，你就会发现它能把特定任务变得多么的容易。 补充内容 s 命令把两个操作合并为一个：它先删除光标下的字符，然后进入插入模式 技巧4 执行、重复、回退在面对重复性工作时，我们需要让移动动作和修改都能够重复，这样就可以达到一个最佳编辑模式。Vim对此的支持是：它会记住我们的操作，并使最常用的操作触手可及，所以我们可以很方便地重复执行它们。本节将介绍 Vim 可以重复执行的每个操作，并学习如何回退这些命令。 当 Vim 让一个操作或移动可以很方便地重复时，它总是会提供某种方式，让我们在不小心做过头时能回退回来。下表总结了Vim中可重复执行的命令，以及相应的回退方式。在多数场景中，撤销（Undo）都是很有用的帮助。 目的 操作 重复 回退 做出一个修改 {edit} . u 在行内查找下一指定字符 f{char}/t{char} ; , 在行内查找上一指定字符 F{char}/T{char} ; , 在文档中查找下一出匹配项 /pattern n N 在文档中查找上一项匹配项 ?pattern n N 执行替换 :s/target/replacement &amp; u 执行一系列修改 qx{changes}q @x u 技巧5 查找并手动替换Vim 提供了一个 :substitute 命令专门用于查找替换任务，不过用上面介绍的技术，我们也可以手动修改第一处地方，然后再一个个地查找替换其他匹配项。 . 命令可以把我们从繁重的工作中解放出来，而即将登场的另一个有用的单键命令，则能够让我们方便地在匹配项间跳转。这样才能逐个决定每一个匹配项是否需要操作。 补充内容 *将文档中光标所在单词全部匹配出来并高亮显示 :set hls 设置高亮显示 cw 命令会删除从光标位置到单词结尾的字符，并进入插入模式 技巧6 结识 . 范式理想模式：用一键移动，另一键执行 所有这些例子都利用 . 命令重复上次的修改，不过这不是它们唯一的共同点，另外的共同点是它们都只需要按一次键就能把光标移到下一个目标上。 用一次按键移动，另一次按键执行，没有再比这更好的了，不是吗？这就是我们的理想解决方案。为了方便起见，我们把它叫做“ . 范式”。 总结回顾前面3个 . 命令编辑任务 在技巧 2 中，我们想在一系列行的结尾添加分号。我们先用 A; &lt;Esc&gt; 修改了第一行，做完这步准备后，就可以使用 . 命令对后续行重复此修改。我们使用了 j 命令在行间移动，要完成剩余的修改，只需简单地按足够多次 j. 就可以了。 在技巧 3 中，我们想为每个 + 号的前后各添加一个空格。我们先用 f+ 命令跳到目标字符上，然后用 s 命令把一个字符替换成 3 个，做完这步准备后，我们就可以按若干次 ;. 完成此任务。 在技巧 5 中，我们想把每处出现单词“content”的地方都替换成“copy”。我们使用 * 命令来查找目标单词，然后用 cw 命令修改第一处地方。做完这步准备后，就可以用 n 键跳到下一匹配项，然后用 . 键做相同的修改。要完成这项任务，只需简单地按足够多次 n. 就行了。 OK","tags":[]},{"title":"Vim的语言性思维","date":"2017-12-28T15:16:48.000Z","path":"2017/12/28/Tool/006. Vim的语言性思维/","text":"GO 本文内容并非原创，而是整理自别人的技术文章。原文请看这里一起来说 Vim 语 1. Vim的常用三种模式 正常模式（进入vim时处于的就是默认模式） 插入模式（编辑文本时的所处的模式） 命令模式（进行保存退出、查找替换、设置等动作时所处的模式） 2. Vim的语言性思维2.1 动词动词代表了我们打算对文本进行什么样的操作。例如： d 表示删除 delete r 表示替换 replace c 表示修改 change y 表示复制 yank v 表示选取 visual select p 表示粘贴 paste 等等…… 2.2 名词名词代表了我们即将处理的文本。Vim 中有一个专门的术语叫做文本对象 text object。例如： w 表示一个单词 word s 表示一个句子 sentence t 表示一个HTML标签 tag p 表示一个段落 paragraph 引号或各种括号 所包含的文本称作一个 文本块 等等…… 2.3 介词介词界定了待编辑文本的范围或者位置。例如： i 表示“在……之内” inside a 表示“环绕” around t 表示“到……位置前” to f 表示“到……位置上” forward 下面是几个有关范围的示意图： 2.4 组词为句有了这些基本的语言元素，我们就可以着手构造一些简单的命令了。文本编辑命令的基本语法如下： 动词 [介词] 名词 下面是一些例子： 删除一个段落: delete inside paragraph–&gt;dip 选取一个句子: visual select inside sentence–&gt;vis 修改一个单词: change inside word–&gt;ciw 修改一个单词: change around word–&gt;caw 删除文本直到字符“x”（不包括字符“x”）: delete to x–&gt;dtx 删除文本直到字符“x”（包括字符“x”）: delete forward x–&gt;dfx 2.5 数词数词指定了待编辑文本对象的数量，从这个角度而言，数词也可以看作是一种介词。引入数词之后，文本编辑命令的语法就升级成了下面这样： 动词 介词/数词 名词 下面是几个例子： 修改三个单词：change three words–&gt;c3w 删除两个单词：delete two words–&gt;d2w 另外，数词也可以修饰动词，表示将操作执行 n 次。于是，我们又有了下面的语法： 数词 动词 名词 请看示例： 两次删除单词（等价于删除两个单词）: twice delete word–&gt;2dw 三次删除字符（等价于删除三个字符）：three times delete character–&gt;3x 3. 结束语以上内容为一种使用Vim的思维方式。 OK","tags":[]},{"title":"Vim的配置","date":"2017-12-27T02:31:17.000Z","path":"2017/12/27/Tool/005. Vim的配置/","text":"GO 1. Vim配置文件说明 Vim的配置文件有两个，/etc/vimrc是Vim的全局配置文件，~/.vimrc是用户的Vim配置文件。一般我们配置的是自己家目录里的这个配置文件~/.vimrc 在Vim的配置文件里，双引号&quot;是注释符 2. 常用Vim配置选项12345678910set hlsearch \"高亮度反白set backspace=2 \"可随时用退格键删除set autoindent \"自动缩排set ruler \"可现实最后一行的状态set showmode \"左下角那一行的状态set nu \"显示行号set background=dark \"显示不同的底色色调set nobackup \"不自动建立*.~备份文件syntax on \"进行语法检验，颜色显示color murphy 3. Vim7.1在Win下的编码设置1234567891011121314151617181920\"设置字体编码\"set guifont=Courier_New:h14:cANSI \" 设置字体 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding=utf-8\"set encoding=utf-8\"set fileencodings=ucs-bom,utf-8,cp936\"set fileencoding=utf-8set encoding=utf-8set fileencodings=utf-8,chinese,latin-1if has(\"win32\") set fileencoding=chineseelse set fileencoding=utf-8endif\"解决菜单乱码source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vim\"解决consle输出乱码\"language messages zh_CN.utf-8 4. 显示相关123456789101112set shortmess=atI \" 启动的时候不显示那个援助乌干达儿童的提示 set number \" 显示行号syntax on \" 语法高亮 set showcmd \" 输入的命令显示出来，看的清楚些 set ruler \" 打开状态栏标尺 set cursorline \" 突出显示当前行\"set magic \" 设置魔术\"set guioptions-=T \" 隐藏工具栏\"set guioptions-=m \" 隐藏菜单栏set laststatus=1 \" 启动显示状态行(1),总是显示状态行(2) \"set statusline=\\ \\ \\ %F%m%r%h%w\\ \\ \\ [FORMAT=%&#123;&amp;ff&#125;]\\ \\ \\ [TYPE=%Y]\\ \\ \\ [POS=%l,%v][%p%%]set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\ \"状态行显示的内容 ~~ 1234567891011\"高亮所在行和所在列的设置se cuc \" 用浅色高亮当前列 se cul \" 用浅色高亮当前行 highlight CursorLine cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE\"highlight CursorColumn cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE\"highlght 主要是用来配色的，包括语法高亮等个性化的配置。可以通过:h highlight，查看详细信息\"CursorLine 和 CursorColumn 分别表示当前所在的行列\"cterm 表示为原生vim设置样式，设置为NONE表示可以自定义设置。\"ctermbg 设置终端vim的背景色\"ctermfg 设置终端vim的前景色\"guibg 和 guifg 分别是设置gvim的背景色和前景色，本人平时都是使用终端打开 vim，所以只是设置终端下的样式 5. 功能相关1234567891011121314151617\" 自动缩进 且 统一缩进为4set autoindentset cindentset softtabstop=4set shiftwidth=4set tabstop=4 \" Tab键的宽度set nobackup \" 从不备份 set autowrite \" 自动保存set backspace=2 \" 使键（backspace）正常处理indent, eol, start等set history=1000 \" 历史记录数set noeb \" 去掉输入错误的提示声音set confirm \" 在处理未保存或只读文件的时候，弹出确认set noexpandtab \" 不要用空格代替制表符set nocompatible \" 不要使用vi的键盘模式，而是vim自己的set ignorecase \" 搜索忽略大小写set cmdheight=2 \" 命令行（在状态行下）的高度，默认为1，这里是2au BufRead,BufNewFile * setfiletype txt \" 高亮显示普通txt文件（需txt.vim脚本） 6. 设置自动缩进本文内容转载自 阿铭Linux centos系统，修改vim的配置文件 /etc/vimrc 添加如下内容： 打开 vimrc ，添加以下语句来使得语法高亮显示： syntax on 如果此时语法还是没有高亮显示，那么在 /etc 目录下的profile文件中添加以下语句： export TERM=xterm-color 解决方向键和退格键失效的问题（采用非兼容模式） set nocompatible set backspace=2 设置 Windows 风格的 C/C++ 自动缩进（添加以下 set 语句到 vimrc 中） 设置（软）制表符宽度为 4 ： set tabstop=4 set softtabstop=4 设置缩进的空格数为 4： set shiftwidth=4 设置自动缩进 ：即每行的缩进值与上一行相等；使用 noautoindent 取消设置： set autoindent 设置 使用 C/C++ 语言的自动缩进方式： set cindent 设置 C/C++ 语言的具体缩进方式 ： set cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s 如果想在左侧显示文本的行号，可以用以下语句： set nu 最后，如果没有下列语句，就加上吧： 12345if &amp;term==\"xterm\" set t_Co=8 set t_Sb=^[[4%dm set t_Sf=^[[3%dmendif 7. 按键相关12345678910111213141516\" 映射全选 ctrl+amap &lt;C-A&gt; ggVG\"map! &lt;C-A&gt; &lt;Esc&gt;ggVGY\"map &lt;F12&gt; gg=G---\" 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; \"+y---\" 选中状态下 Ctrl+x 剪切vmap &lt;C-x&gt; \"+d---\"列出当前目录文件 map &lt;F3&gt; :tabnew .&lt;CR&gt; ---\"打开树状文件目录 map &lt;C-F3&gt; \\be 8. 编程相关8.1. 未分类1234567set showmatch \" 高亮显示匹配的括号set matchtime=1 \" 匹配括号高亮的时间（单位是十分之一秒）set smartindent \" 为C程序提供自动缩进filetype on \" 侦测文件类型filetype plugin on \" 载入文件类型插件filetype indent on \" 为特定文件类型载入相关缩进文件 8.2. 自动补全1234567891011121314151617set completeopt=longest,menu \"打开文件类型检测, 加了这句才可以用智能补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;=ClosePair('&#125;')&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;:inoremap \" \"\"&lt;ESC&gt;i:inoremap ' ''&lt;ESC&gt;ifunction! ClosePair(char) if getline('.')[col('.') - 1] == a:char return \"\\&lt;Right&gt;\" else return a:char endifendfunctionfiletype plugin indent on 8.3. C、C++ 按F5编译运行，按F8调试1234567891011121314151617181920212223map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec \"w\" if &amp;filetype == 'c' exec \"!g++ % -o %&lt;\" exec \"! ./%&lt;\" elseif &amp;filetype == 'cpp' exec \"!g++ % -o %&lt;\" exec \"! ./%&lt;\" elseif &amp;filetype == 'java' exec \"!javac %\" exec \"!java %&lt;\" elseif &amp;filetype == 'sh' :!./% endifendfuncmap &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb() exec \"w\" exec \"!g++ % -g -o %&lt;\" exec \"!gdb ./%&lt;\"endfunc 8.4. 新建.c、.h、.sh、.java、.py等文件时，自动插入文件头12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879autocmd BufNewFile *.cpp,*.[ch],*.sh,*.py,*.java exec \":call SetTitle()\" \"定义函数SetTitle，自动插入文件头let $author_name = \"Theshu\"let $author_email = \"theshu@qq.com\"func SetTitle() \"如果文件类型为.py文件 if &amp;filetype == 'python' call setline( 1,\"\\#!/usr/bin/python\") call append(line(\".\"),\"\\#########################################################################\") call append(line(\".\")+1, \"\\# File Name : \".expand(\"%\")) call append(line(\".\")+2, \"\\# Program : \") call append(line(\".\")+3, \"\\# \\t &gt; \") call append(line(\".\")+4, \"\\# Author : \".$author_name) call append(line(\".\")+5, \"\\# Email : \".$author_email) call append(line(\".\")+6, \"\\# Created Time: \".strftime(\"%c\")) call append(line(\".\")+7, \"\\# History : \") call append(line(\".\")+8, \"\\#########################################################################\") call append(line(\".\")+9, \"\") endif\"如果文件类型为.sh文件 if &amp;filetype == 'sh' call setline( 1,\"\\#!/bin/bash\") call append(line(\".\"),\"\\#########################################################################\") call append(line(\".\")+1, \"\\# File Name : \".expand(\"%\")) call append(line(\".\")+2, \"\\# Program : \") call append(line(\".\")+3, \"\\# \\t &gt; \") call append(line(\".\")+4, \"\\# Author : \".$author_name) call append(line(\".\")+5, \"\\# Email : \".$author_email) call append(line(\".\")+6, \"\\# Created Time: \".strftime(\"%c\")) call append(line(\".\")+7, \"\\# History : \") call append(line(\".\")+8, \"\\#########################################################################\") call append(line(\".\")+9, \"\") endif\"如果文件为C++的*.cpp if &amp;filetype == 'cpp' call setline(1, \"/*************************************************************************\") call append(line(\".\"), \" &gt; File Name: \".expand(\"%\")) call append(line(\".\")+1, \" &gt; Program: \") call append(line(\".\")+2, \"\\t\\t &gt; \") call append(line(\".\")+3, \" &gt; Author: \".$author_name) call append(line(\".\")+4, \" &gt; Email: \".$author_email) call append(line(\".\")+5, \" &gt; Created Time: \".strftime(\"%c\")) call append(line(\".\")+6, \" ************************************************************************/\") call append(line(\".\")+7, \"\") call append(line(\".\")+8, \"#include&lt;iostream&gt;\") call append(line(\".\")+9, \"using namespace std;\") call append(line(\".\")+10, \"\") endif\"如果文件为C的*.c或*.h if &amp;filetype == 'c' call setline(1, \"/*************************************************************************\") call append(line(\".\"), \" &gt; File Name: \".expand(\"%\")) call append(line(\".\")+1, \" &gt; Program: \") call append(line(\".\")+2, \"\\t\\t &gt; \") call append(line(\".\")+3, \" &gt; Author: \".$author_name) call append(line(\".\")+4, \" &gt; Email: \".$author_email) call append(line(\".\")+5, \" &gt; Created Time: \".strftime(\"%c\")) call append(line(\".\")+6, \" ************************************************************************/\") call append(line(\".\")+7, \"\") call append(line(\".\")+8, \"#include&lt;stdio.h&gt;\") call append(line(\".\")+9, \"\") endif\"如果文件为Java的*.java if &amp;filetype == 'java' call setline(1, \"/*************************************************************************\") call append(line(\".\"), \" &gt; File Name: \".expand(\"%\")) call append(line(\".\")+1, \" &gt; Program: \") call append(line(\".\")+2, \"\\t\\t &gt; \") call append(line(\".\")+3, \" &gt; Author: \".$author_name) call append(line(\".\")+4, \" &gt; Email: \".$author_email) call append(line(\".\")+5, \" &gt; Created Time: \".strftime(\"%c\")) call append(line(\".\")+6, \" ************************************************************************/\") call append(line(\".\")+7, \"\") call append(line(\".\")+8, \"\") call append(line(\".\")+9, \"\") endif\"新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal Gendfunc OK","tags":[]},{"title":"Vim的一些问题总结","date":"2017-12-26T13:52:54.000Z","path":"2017/12/26/Tool/004. Vim的一些问题总结/","text":"GO 本章内容包含了很多在Vim使用中出现的问题以及相应的解决方法。 1. putty或xshell连接linux中Vim的小键盘问题 本内容容转载自 阿铭Linux 在putty上用Vim的时候，开NumLock时按小键盘上的数字并不能输入数字，而是出现一个字母然后换行（实际上时普通模式下对应上下左右的键。解决方法： 选项Terminal-&gt;Features里，找到Disabled application keypad mode，选上就可以了。 在xmanager 4 中也有小键盘的问题。解决方法为： 修改session属性-&gt;终端-&gt;VT模式-&gt;初始数字键盘模式 选择 设置为普通 2. Vim粘贴乱码问题 本节内容转载自 阿铭Linux 用Vim打开一个空白文档，然后把已经复制的代码粘贴进来，发现它有自动缩进功能，最终导致粘贴的文本一行比一行靠右，看起来乱成一团。 比较快的解决办法是： 在粘贴问当前，在命令模式下，输入：:set noai nosi 然后按“i”进入编辑模式，再粘贴已经复制的代码内容，这样就不会有自动缩进了。 有时候，这样的方法不好用，可以尝试这种： :set paste 3. Vim文件加密 本文内容转载自 阿铭Linux 利用Vim给文件加密： 优点：加密后，如果不知道密码，就看不到明文，包括root用户也看不了； 缺点：很明显让别人知道加密了，容易让别人把加密的文件破坏掉，包括内容破坏和删除； Vim里有一个命令是给文件加密的，举个例子： 首先在root主目录/root/下建立一个实验文件text.txt：[root@www ~]# vim/vi text.txt 进到编辑模式，输入完内容后按ESC，然后输入:X（注意是大写的X），回车； 这时系统提示让你输入密码，2次，如下所示： 12输入密码: *******请再输入一次: ******* 保存后退出，现在这个文件已经加密了； 用cat或more查看文件内容，显示为乱码；用 vim/vi 重新编辑这个文件，会提示输入密码，如果输入的密码不正确，同样会显示为乱码！注意：文件加密后，千万别忘了密码！ 解密用vi加密的文件（前提是你知道加密的密码）： 用 vim/vi 打开文件如text.txt，要输入正确的密码，然后在编辑时，将密码设置为空，方法是输入下面的命令：:set key=，然后直接回车，保存文件后，文件已经解密了。 或者这样也行：在正确打开文件后用 “:X” 指令，然后给一个空密码也可以。保存用“wq!”保存。 说明：以上两种方法实际上效果是一样的。 4. Vim中:wq和:x的区别 本节内容转载自 阿铭Linux :x和:wq的区别如下： :wq 强制性写入文件并退出（存盘并退出 write and quit）。即使文件没有被修改也强制写入，并更新文件的修改时间。 :x 写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。 说明：这两者一般情况下没有什么不一样，但是在编程方面，对编辑源文件可能会产生重要影响。因为文件即使没有修改，“:wq”强制更新文件的修改时间，这样也会让make编译整个项目时以为文件被修改过了，然后就得重新编译链接生成可执行文件。这可能会产生让人误解得后果，当然也产生了不必要得系统资源花销。不过像是版本控制得软件一般首选还是比较文件内容，修改时间一般不加以理会。 OK","tags":[]},{"title":"入门Linux运维工程师需要学习的内容","date":"2017-12-25T14:59:40.000Z","path":"2017/12/25/转载/003. 入门Linux运维工程师需要学习的内容/","text":"GO 0. 前言Linux系统的学习，可以选用RedHat或CentOS，特别是CentOS，在企业用得最多，当然还会有其它版本的，但学习者还是以这两个版本学习就行，因为这两个版本是兄弟，没有什么区别。有空还可以再研究一下SUSE，有些公司也喜欢用。 对于刚入门或准备入门Linux运维的来说，我们也整理总结了一下10个必须掌握的技术点和相关工具。 1. Linux系统基础这个是基础中的基础，连这个都不会就别干了。参考书籍，可以看《鸟哥Linux基础篇》，至少要掌握这书60%的内容，没有必要全部都掌握，但基本命令总得会把。 2. 网络服务服务有很多种，没个公司都会用到不同的，但基础的服务肯定要掌握： 如FTP、DNS、SAMBA、邮件，这几个大概学一下就行 LAMP和LNMP是必须要熟练，我所指的不是光光会搭建，而是要很熟悉里面的相当配置才行 因为公司最关键的绝对是Web服务器，所以Nginx和apache要熟悉，特别是Nginx一定要很熟悉才行 至少有些公司还会用Tomcat，这个也最好学一下。 其实网络服务方面不用太担心，一般公司的环境都已经搭建好，就算有新服务器或让你整改，公司会有相应的文档让你参照来弄，不会让你乱来的，但至少相关的配置一定要学熟，而且肯定是编译安装多，那些模块要熟悉一下它的作用，特别是PHP的那些模块。 前面1和2两点只是基础，也是必要的条件，不能说是工具，以下才是真正要掌握的工具。 3. Shell脚本和另一个脚本语言Shell是运维人员必须具备的，不懂这个连入职都不行，至少也要写出一些系统管理脚本，最简单也得写个监控CPU、内存比率的脚本吧，这是最最最基本的了，别以为会写哪些猜数字和计算什么数的吗，这些没什么用，只作学习意义，写系统脚本才是最有意义。 而另一个脚本语言是可选的，一般是3P：Python、Perl和PHP。PHP就不需要考虑了，除非你要做开发，我个人建议学Python会比较好，难实现自动化运维，Perl是文本处理很强大，反正这两个学一个就好了。 4. grep、sed 和 awk工具必须要掌握。这三个工具称为“正则三剑客”！在掌握这些工具的同时，还要掌握正则表达式，这个就痛苦了，正则是最难学的表达式，但结合到这三个工具中会很强大，在处理文本内容和过滤Web内容时十分有用，不过在学Shell的同时，一般会经常结合用到的，所以学第3点就会顺便学第4点。 5. 文本处理命令sort、tr、cat、paste、uniq、tee等，必学内容，也是结合第3点时一并学习的。 6. 数据库首选MySQL，别问我为什么不学SQLServer和Oracle，因为Linux用的最多的绝对是MySQL，增删该查必须学，特别要学熟练，其它方面可能不太需要，因为运维人员使用最多的还是查，那些优化和开发语句不会让你弄的。 7. 防火墙不学不行，防火墙也算是个难点，说难不难，说易不易，最重要的是要弄懂规则，如果学过CCNA的朋友可能会比较好学，因为iptables也有NAT表，原理是一样的，而FILTER表用的最多，反正不学就肯定不合格。 8. 监控工具十分十分重要，我个人建议，最好学习这3个：cacti、nagios和zibbix，企业用得最多的应该是nagios和zibbix，反正都学吧 ，但nagios会有点难，因为会设计到用脚本写自动监控，那个地方很难。 9. 集群和热备这个很重要，肯定要懂的，但到了公司就不会让你去弄，因为新手基本不让你碰，集群工具有很多，最好学LVS，这是必学，最好也学学nginx集群、反向代理，还有热备，这个就有更多工具能实现了。MySQL热备也要学，就是主从复制，这个别告诉我容易，其实是不容易的，要学懂整个流程一点也不容易，只照着做根本没有意思。 10. 数据备份不学不行，工具有很多，但至少要把RAID的原理弄懂，特别是企业最常用的1+0或0+1，自己做实验也要弄出来。备份工具有很多，如tar、dump、rsync等，最好多了解一下。 11. 结束语说到这10点已经够你受的了，应该可以入门了，因为有些技术会比较难学，例如apache和Nginx中还有些很重要的技术，如系统调优和服务优化，还有程序优化，这些在没接触工作之前很难学习到的，所以先把这10点学了吧，估计要学习3个月不止。 就脚本那部分已经让你很吃力了，我建议先学熟Shell，等工作后再学另一门脚本语言，这样会比较好。 以上就是踏入Linux运维工程师需要掌握的工具，其实还有很多工具要掌握的，但你在学习环境中是很难学到的。最好，我灾提醒一下，这里所指的工具相当于技能，而不是像Windows和Ubuntu那些图形化工具，那些工具没用的，还有，学Linux就别用图形界面，这样虚拟机就不用吃太多内存。 OK","tags":[]},{"title":"C和C++高手修炼之路","date":"2017-12-25T14:47:12.000Z","path":"2017/12/25/转载/002. C和C++高手修炼之路/","text":"GO 一、C/C++语言买两本基础书，把例子都敲一遍，把基础的知识该掌握的都掌握好。 二、带界面的应用程序 微软路线：MFC 开源路线：界面库多的是 通用的并且简单的就是 wxWidget，官网：www.wxwidgets.org。 三、网络应用程序《Unix网络编程》，学号这本书，自己动手写一个服务器，再写一个客户端。请务必学会select这个简单的多路复用模型，这样才能慢慢的深入里面的poll、epoll、IOCP之类的模型。 四、文件操作fopen、fclose、fread、fwrite、fseek、ftell。 五、深刻理解内存与指针的关系内存的分配释放。可以看《高质量C/C++编程》中的例子。 六、apache源代码，仔细研究它apache的源代码是高手中的高手写的。尤其要学习其中的很多编程思想。 七、修炼C++泛型编程思想。 八、深研设计模式设计模式是程序设计的灵魂，是通用方法，当你面对一个大型项目的时候，如歌设计一个有弹性的系统，是所有系统分析员应该掌握的技能。在设计模式的研究上，要结合实际的项目进行。 OK","tags":[]},{"title":"Vim初学笔记","date":"2017-12-25T05:45:28.000Z","path":"2017/12/25/Tool/003. Vim初学笔记/","text":"GO 0. Vim初相识0.1 Vim简介Vim是从Vi发展出来，第一个版本由布拉姆米勒在1991年发布，它基于VIM许可证，兼容GPL。官网www.vim.org 0.2 Vim的安装和使用 安装：yum install -y vim-enhanced 使用：vim filename 1. Vim的模式（这节内容摘抄自Vim-维基百科） Vim有6种基本模式和5种派生模式： 1.1 基本模式 普通模式 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按”a”（append／追加）键或者”i”（insert／插入）键。 插入模式 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。 在插入模式中，可以按ESC键回到普通模式。 可视模式 这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。 选择模式 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 命令行模式 在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（”:”键），搜索（”/“和”?”键）或者过滤命令（”!”键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式 这和命令行模式比较相似，在使用”:visual”命令离开Ex模式前，可以一次执行多条命令。 1.2 派生模式 操作符等待模式 这个派生模式指普通模式中，执行一个操作命令后Vim等待一个”动作”来完成这个命令。Vim也支持在操作符等待模式中使用”文本对象”作为动作，包括”aw”一个单词（a word）、”as”一个句子（a sentence）、”ap”一个段落（a paragraph）等等。 比如，在普通模式下”d2as”删除当前和下一个句子。在可视模式下”apU”把当前段落所有字母大写。 插入普通模式 这个模式是在插入模式下按下ctrl-o键的时候进入。这个时候暂时进入普通模式，执行完一个命令之后，Vim返回插入模式 插入可视模式 这个模式是在插入模式下按下ctrl-o键并且开始一个可视选择的时候开始。在可视区域选择取消的时候，Vim返回插入模式。 插入选择模式 通常这个模式由插入模式下鼠标拖拽或者shift方向键来进入。当选择区域取消的时候，Vim返回插入模式。 替换模式 这是一个特殊的插入模式，在这个模式中可以做和插入模式一样的操作，但是每个输入的字符都会覆盖文本缓冲中已经存在的字符。在普通模式下按”R”键进入。 1.3 其它 Evim（Easy Vim） Evim（Easy Vim）是一个特殊的GUI模式用来尽量的表现的和”无模式”编辑器一样。编辑器自动进入并且停留在插入模式，用户只能通过菜单、鼠标和键盘控制键来对文本进行操作。可以在命令行下输入”evim”或者”vim -y”进入。在Windows下，通常也可以点击桌面上Evim（Easy Vim）的图标。 1.4 说明一般情况下，我们通常只使用三种模式（其它的模式可能会在我们使用过程中不经意就会用上，所以初学时不要在模式上花费太大的精力，只需要搞懂这常用的三种就足够了）： 普通模式 插入模式 命令行模式 以下的内容也是针对这三种常用模式的学习。 2. Vim的使用2.1 进入Vim vim 进入Vim软件环境 vim filename 用Vim打开或新建一个文件 2.2 三种常用模式之间的切换2.2.1 进入普通模式 一般用Vim打开文件时的默认模式就是普通模式。 如果是在别的模式下，按Esc键 就会切换到普通模式。 同上，按 Ctrl+C 或者 Ctrl+[ 效果也同 按Esc键。 2.2.2 进入插入模式一般是从默认的普通模式进入到插入模式，常用的方式如下表所示： 按键 说明 i 在当前光标的前面插入 I 在当前光标所在行的行首插入 a 在当前光标的后面插入 A 在当前光标所在行的行尾插入 o 在当前光标所在行的下面新插入一行 O 在当前光标所在行的上面新插入一行 cw 替换从光标所在位置后到一个单词结尾的字符 2.2.3 进入命令行模式一般是从默认的普通模式进入到命令行模式，方式如下表所示： 按键 说明 ： 冒号后面加一些命令 / 进行查找替换时前面要用它 ？ 进行查找时前面要用它 2.2.4 关于模式之间相互切换的说明 普通模式和插入模之间可以相互切换。 普通模式和命令行模式之间可以相互切换。 插入模式和命令行模式之间不可以直接切换，只能先从一种模式中切换到普通模式，才能再切换到另一个模式。 2.3 光标移动光标移动 按键 说明 h/左箭头 左 l/右箭头 右（小写L） j/下箭头 下 k/上箭头 上 行间跳转 命令 说明 nG（n Shift+g） 光标移动到第n行 gg 光标移动到第一行 G（Shift+g） 到最后一行 小技巧：你在完成依次跳转后，可以使用Ctrl+o快速回到上一次(跳转前)光标所在位置,这个技巧很实用，比如当你在写代码时，忽然想起有个bug，需要修改，这时候你跳过去改好了，只需要按下Ctrl+o就可以回到你之前的位置。 行内跳转 命令 说明 w 到下一个单词的开头 e 到下一个单词的结尾 b 到前一个单词的开头 ge 到前一个单词的结尾 0或^ 到行头 $ 到行尾 f&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配的位置（非常实用） F&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配的位置 t&lt;字母&gt; 向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母（不常用） T&lt;字母&gt; 向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母（不常用） 2.4 操作文本2.4.1 删除文本普通模式下删除Vim文本信息 操作 说明 x（小写） 删除光标所在的字符 X（大写） 删除光标所在前一个字符 Delete 同x dd 删除（实际上是剪切，可用p来粘贴）光标所在行 dw 删除一个单词（不适合中文） d$或D 删除至行尾 d^ 删除至行首 dG 删除至文档结尾处 d1G 删除至文档首部 除此之外，还可以在命令之前加上数字，表示多次删除1行，即一次删除多行。 2.4.2 复制粘贴和剪切在普通模式下进行复制粘贴和剪切的操作 操作 说明 yy 复制光标所在行的整行 3yy 复制3行 y^ 复制至行首的第一个字符，不包含光标所在处字符 y0 同上 yw 复制一个单词 y2w 复制两个单词 yG 复制至文本末 y1G 复制至文本开头 p（小写） 粘贴至光标后（下） P（大写） 粘贴至光标前（上） dd 剪切光标所在行的整行 ddp 快速交换光标所在行与它下面的行 剪切的操作 同复制的操作一致，以此类推 2.4.3 替换和撤销（Undo）在普通模式下进行 操作 说明 r+&lt;待替换字母&gt; 将光标所在字母替换为指定字母 R 连续替换，直到按下Esc cc 替换整行，即删除光标所在行，并进入插入模式 cw 替换一个单词，即删除一个单词，并进入插入模式 C（大写） 替换光标以后至行末 ~ 反转光标所在字母大小写 u{n} 撤销一次或n次操作 U（大写） 撤销当前行的所有修改 Ctrl+r redo，即撤销undo的操作 2.4.4 查找在普通模式下进行 操作 说明 /&lt;字符串&gt; 向下进行查找 ?&lt;字符串&gt; 向上进行查找 n（小写） 继续相同侧的查找 N（大写） 继续相反侧的查找 \\* 向下查找光标所在处的单词 \\# 向上查找光标所在处的单词 g\\* 同\\*，但部分符合该单词即可 g\\# 同\\#，但部分符合该单词即可 补充说明：1234加入old中包含“/”这个字符就需要反斜杠|转换或将/换成#或@1. :%s/\\/etc\\/old/new/g2. :%s#/etc/old#new#g3. :%s@/etc/old@new@g 2.4.5 快速缩进使用快速缩进，用于格式化代码超爽，在普通模式下进行 操作 说明 &gt;&gt; 将整行向右缩进 &lt;&lt; 将整行向左回退 :set shiftwidth=n 设置缩进和回退的字符数（可以简写成sw) :ce 使本行内容居中 :ri 使本行内容靠右 :le 使本行内容靠左 2.5 Vim重复命令和设置2.5.1 Vim重复命令 重复执行上次命令：在普通模式下，.（小数点）表示重复上一次的命令操作。 执行指定次数相同的命令：在普通模式输入数字N，N表示重复后面操作的次数。几个例子如下: 输入 10x ,删除10个连续字符 输入 3dd ,将会删除3行文本 在普通模式下，还可以使用dw或者daw（delete a word）删除一个单词，所以可以联想到dnw（n替换为相应数字）表示删除n个单词。 2.5.2 Vim常用设置 :set nu 显示行号 :set shiftwidth=n 设置缩进和回退的字符数（可以简写成sw–&gt; :set sw=n ） :set nohl 取消查找关键字后的高亮 2.6 退出Vim命令行模式下退出Vim 命令 说明 :q! 强制退出，不保存 :q 退出 :wq! 强制保存并退出 :w &lt;文件路径&gt; 另存为 :saveas &lt;文件路径&gt; 另存为 :x 保存并退出 :wq 保存并退出 普通模式下输入 ZZ（Shift+zz） 即可退出（若文件改动，则保存，否则不保存） 3. Vim初学的补充3.1. 正常模式下的命令格式在正常模式下一个命令的格式是∶ [number] command object 或者 command [number] object 其意是∶ number - 代表的是命令执行的次数 command - 代表要做的事情，比如 d 代表删除 object - 代表要操作的对象，比如 w 代表单字/单词，$ 代表到行末等等。 $ (to the end of line), etc. 3.2. 括号匹配如果光标当前位置是括号(、)、[、]、{、}，按 % 可以将光标移动到配对的括号上。 3.3. 字符替换 在一行内替换头一个字符串 old 为新的字符串 new，请输入 :s/old/new 在一行内替换所有的字符串 old 为新的字符串 new，请输入 :s/old/new/g 在两行内替换所有的字符串 old 为新的字符串 new，请输入 :#,#s/old/new/g 在文件内替换所有的字符串 old 为新的字符串 new，请输入 :%s/old/new/g 进行全文替换时询问用户确认每个替换需添加 c 选项，请输入 :%s/old/new/gc 3.4. Vim的在线帮助命令 Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方法之一∶ 按下 &lt;HELP&gt; 键 (如果键盘上有的话) 按下 &lt;F1&gt; 键 (如果键盘上有的话) 输入 :help &lt;回车&gt; 输入 :q &lt;回车&gt; 可以关闭帮助窗口。 提供一个正确的参数给”:help”命令，您可以找到关于该主题的帮助。请试验以下参数(可别忘了按回车键哦)∶ :help w &lt;回车&gt; :help insert-index &lt;回车&gt; :help user-manual &lt;回车&gt; vim手册，使用的命令是∶ :help user-manual 4. Vim高级功能4.1. 多文件编辑4.1.1 使用Vim编辑多个文件编辑多个文件有两种形式，一种是在进入Vim前使用的参数就是多个文件，另一种就是进入Vim后再编辑其他的文件。 同时创建两个新文件并编辑： vim 1.txt 2.txt 默认进入1.txt文件的编辑界面 命令行模式下输入:n 编辑2.txt文件，可以加!即:n!强制切换，之前一个文件的输入内容没有保存，仅仅切换到另一个文件 命令行模式下输入:N 编辑1.txt文件，可以加!即:N!强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件。 4.1.2 进入Vim后打开新文件命令行模式下的操作： 操作 说明 :e 3.txt 打开新文件3.txt :e# 回到前一个文件 :ls 可以列出以前编辑过的文档 :b 2.txt（或者编号） 可以直接进入文件2.txt编辑 :bd 2.txt（或者编号） 可以删除以前编辑过的列表中的文件项目 :e! 4.txt 新打开文件4.txt，放弃正在编辑的文件 :f 显示正在编辑的文件名 :f new.txt 改变正在编辑的文件名字为new.txt 4.1.3 恢复文件如果因为断电等原因造成文档没有保存，可以采用恢复方式： vim -r 进入文档后，输入:ewcover 1.txt来恢复。 4.2. 可视模式 在普通模式下输入v（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v会后就会取消选取。 在普通模式下输入Shift+v（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次Shift+v就可以取消选取。 在普通模式下输入Ctrl+v（小写），这是区域选择模式，可以进行矩形区域选择，再按一次Ctrl+v取消选取。 在普通模式下输入d删除选取区域内容 在普通模式下输入y复制选取区域内容 4.3. 视窗操作vim可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为vim的视窗。打开方法有很多种，例如可以使用在命令行模式下输入:new 打开一个新的vim视窗，并进入视窗编辑一个新文件（普通模式下输入Ctrl+w也可以,但是Ctrl+w在chrome下会与chrome关闭标签页的快捷键冲突，所以使用该快捷键你可以在IE或其它浏览器进行练习），除了:new命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗： 命令行模式下输入:sp 1.txt 打开新的横向视窗来编辑1.txt 命令行模式下输入:vsp 2.txt 打开新的纵向视窗来编辑1.txt 普通模式下Ctrl-w s 将当前窗口分割成两个水平的窗口 普通模式下Ctrl-w v 将当前窗口分割成两个垂直的窗口 普通模式下Ctrl-w q 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! 普通模式下Ctrl-w o 打开一个视窗并且隐藏之前的所有视窗 普通模式下Ctrl-w j 移至下面视窗 普通模式下Ctrl-w k 移至上面视窗 普通模式下Ctrl-w h 移至左边视窗 普通模式下Ctrl-w l 移至右边视窗 普通模式下Ctrl-w J 将当前视窗移至下面 普通模式下Ctrl-w K 将当前视窗移至上面 普通模式下Ctrl-w H 将当前视窗移至左边 普通模式下Ctrl-w L 将当前视窗移至右边 普通模式下Ctrl-w - 减小视窗的高度 普通模式下Ctrl-w + 增加视窗的高度 4.4. 文档加密vim -x file1 输入您的密码确认密码这样在下一次打开时，vim就会要求你输入密码 4.5. 在Vim执行外部命令在命令行模式中输入!可以执行外部的shell命令: :!ls 用于显示当前目录的内容 :!rm FILENAME 用于删除名为 FILENAME 的文件 :w FILENAME 可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件 4.6. Vim的帮助系统 普通模式下按&lt;F1&gt;打开vim自己预设的帮助文档 命令行模式下输入:h shiftwidth 打开名为shiftwidth的帮助文件 命令行模式下输入:ver 显示版本及参数 4.7. 功能设定4.7.1 Vim的功能设定可以在编辑文件的时候进行功能设定，如命令行模式下输入:set nu（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。vim的配置文件~/.vimrc，可以打开文件进行修改，不过务必小心不要影响vim正常使用 4.7.2 获取目前的设定 命令行模式下输入:set或者:se显示所有修改过的配置 命令行模式下输入:set all 显示所有的设定值 命令行模式下输入:set option? 显示option的设定值-命令行模式下输入:set nooption 取消当期设定值 4.7.3 set功能的说明 命令行模式下输入:set autoindent(ai) 设置自动缩进 命令行模式下输入:set autowrite(aw) 设置自动存档，默认未打开 命令行模式下输入:set background=dark或light，设置背景风格 命令行模式下输入:set backup(bk) 设置自动备份，默认未打开 命令行模式下输入:set cindent(cin) 设置C语言风格缩进 5. Vim使用技巧总结5.1. Vim一些常用使用技巧总结 操作 说明 Ctrl-C 回到普通模式 u / Ctrl+r 撤销/反撤销 9G / :9 定位到第9行 :9y 拷贝第9行 Ctrl-o 回到此前光标位置 ZZ / ZQ 保存并退出/无条件退出 = 格式化选定文本 ggvG 全选文件内容 gg=G 格式化文件 Shift-v 选取行 vip 选取光标所在段落 yit / dit / cit 对标签内的文本进行操作 mx 添加书签 `X 跳转到书签X :marks 查看所有书签X delm X 删除书签X :ls 查看缓冲区 :bN 打开缓冲区N :bn / bp / 缓冲区切换 :shell / :sh /!cmd 执行shell命令 Ctrl-z / fg 利用了Linux的作业机制，将Vim进程放到后台/前台执行，便于使用shell环境 vim -o *.py 打开当前目录下全部.py文件 :qa 退出全部窗口 vnew 垂直分屏 Ctrl-w r 切换缓冲区 :r filename 将文件读入到当前光标位置 Windo diffthis/diffof 对比当前打开的两个缓冲区 :e! 重新打开缓冲区 :s/foo/bar/gc 查找foo并将其替换成bar :1?xxx / G?xxx 从文件末尾开始查找 Shift-k 查找光标所在命令或函数的man帮助 J 合并行 gi / gk 对于换行的段落的行移动 Ctrl-g 用于显示当前光标所在位置和文件状态信息。 :!command 用于执行一个外部命令 command。 :w FILENAME 可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中。 :#,#w FILENAME 可将当前编辑文件第 # 行至第 # 行的内容保存到文件FILENAME 中。 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 5.2. Vim键盘图图一 图二 图三 OK","tags":[]},{"title":"常用便携软件","date":"2017-12-19T04:43:10.000Z","path":"2017/12/19/Tool/002. 常用便携软件/","text":"GO 便携软件平台 PortableApps.com PortableAppC Sourceforge 便携软件平台软件 PortableApps.com_Platform 常用便携软件清单 PDF阅读 | Sumatro PDF 拼音输入 | Sogou Pinyin 办公套件 | LibreOffice 编辑神器 | Gvim 截屏工具 | PicPick 截屏神器 | Ashampoo Snap 魔影工厂 | Modiac Factory 视频播放 | PotPlayer 视频播放 | SMPlayer 音乐播放 | AirPlay 快速搜索 | Everything 垃圾清理 | Wise Disk Cleaner 密码管理 | KeePass Classic 软件卸载 | GeekUninstaller 数据恢复 | Wise Disk Recovery 文件比较 | Checksum Control 系统安装 | UNetbootin 压缩解压 | 7-Zip 占用解锁 | Obit Unlocker 资源管理 | FreeCommander XE 资源平衡 | Process lasso 网页浏览 | Google Chrome 网页浏览 | Mozilla FireFox 迅雷迷你 | ThunderMini 迅雷下载 | Thunder 远程文件 | WinSCP 远程终端 | KiTTY 远程终端 | PuTTY OK","tags":[]},{"title":"FTP服务配置（Aming）","date":"2017-09-21T14:01:40.000Z","path":"2017/09/21/服务/002. FTP服务配置（Aming）/","text":"GO FTP介绍FTP是File Transfer Protocol（文件传输协议，简称”文传协议”）的英文简写形式，用于在互联网上控制文件的双向传输。它同时也是一个应用程序，用户可以通过它把自己的PC机与世界各地所有运行FTP协议的服务器相连，以访问服务器上的大量程序和信息。FTP的主要作用就是让用户连接一个远程计算机（这些计算机上运行着FTP服务器程序），并查看远程计算机中的文件，然后把文件从远程计算机复制到本地计算机，或把本地计算机的文件传送到远程计算机。FTP方便传输数据，所以个人用户很多，但在企业里用得越来越少，因为FTP是有一定安全隐患的。在本章会介绍两种FTP软件。 使用vsftpd搭建FTP服务CentOS或RHEL上有自带的FTP软件vsftpd，默认并没有安装，需要用yum安装，安装后不用配置，启动后便可以使用。但本节介绍的是它的高级用法。 1. 安装 vsftpdyum install -y vsftpd db4-utils 这里安装了两个软件包，同时也会把依赖的包安装上。其中db4-utils包用来生成密码库文件。 2. 建立账号vsftpd默认可以支持使用系统账号体系登陆，但是那样不太安全，所以建议使用虚拟账号体系登陆。 首先建立与虚拟账号相关联的系统账号：useradd virftp -s /sbin/nologin 接着建立与虚拟账户相关的文件：vim /etc/vsftpd/vsftpd_login，其内容如下： 1234test1123456test2abcdfe 需要说明的是，该文件的奇数行为用户名，偶数行为上一行的用户密码。 更改文件的权限，提升安全级别：chmod 600 /etc/vsftpd/vsftpd_login vsftpd使用的密码不是明文的，需要生成对应的库文件：db_load -T -t hash -f /etc/vsftpd/vsftpd_login /etc/vsftpd/vsftpd_login.db 最后建立与虚拟账号相关的目录以及配置文件： mkdir /etc/vsftpd/vsftpd_user_conf cd /etc/vsftpd/vsftpd_user_conf 3. 创建和用户对应的配置文件用户的配置文件是单独存在的，每一个用户都有一个自己的配置文件，文件名和用户名一致。如下所示：123456789101112# vim test1 //内容如下local_root=/home/virftp/test1anonymous_enable=NOwrite_enable=YESlocal_umask=022anon_upload_enable=NOanon_mkdir_write_enable=NOidle_session_timeout=600data_connection_timeout=120max_clients=10max_per_ip=5local_max_rate=50000 说明： local_root为test1账号的家目录 anonymous_enable用来限制是否允许匿名账号登陆（若为NO，表示不允许匿名账号登陆） write_enable=YES表示可写 local_umask指定umask值 anon_upload_enable表示是否允许匿名账号上传文件 anon_mkdir_write_enable表示是否允许匿名账号可写 以上为关键配置参数，其他参数暂时不用关心 创建test2账号的步骤和test1一样，如下所示：123456# mkdir /home/virftp/test1# touch /home/virftp/test1/aminglinux.txt# chown -R virftp:virftp /home/virftp# vim /etc/pam.d/vsftpd //在最开头添加两行auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_loginaccount sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login 说明： CentOS7为64位系统，所以库文件路径为/lib64/security/pam_userdb.so（32位系统的库文件路径为/lib/security/pam_userdb.so） 4. 修改全局配置文件/etc/vsftpd/vsftpd.conf修改用户的配置文件后还不可用，还需要修改vsftpd的一些全局配置文件。 首先编辑vsftpd.conf文件，如下所示：12345678910111213# vim /etc/vsftpd/vsftpd.conf //修改如下内容- 将anonymous_enable=YES 改为 anonymous_enable=NO- 将#anon_upload_enable=YES 改为 anon_upload_enable=NO- 将#anon_mkdir_write_enable=YES 改为 anon_mkdir_write_enable=NO// 再增加如下内容chroot_local_user=YESguest_enable=YESguest_username=virftpvirtual_use_local_privs=YESuser_config_dir=/etc/vsftpd/vsftpd_user_confallow_writeable_chroot=YES 然后启动vsftpd服务，执行如下命令：systemctl start vsftpd 测试安装是否成功以上所示的整个配置过程有点繁琐，但是并不复杂。接下来我们做一下测试： ps aux | grep vsftp 查看进程是否存在 yum install -y lftp 安装lftp客户端软件 lftp test1@127.0.0.1 输入口令后即可登陆到vsftpd，然后利用ls命令查看test1家目录下面的aminglinux.txt。文件的所属主和所属组以virftp用户的UID和GID的方式显示。 如果在这一步遇到问题，请检查/var/log/secure日志，通常会记录一些错误信息。 使用pure-ftpd搭建FTP服务pure-ftpd为另一款比较小巧实用的FTP软件，平时用的比较多。 1. 安装 pure-ftpd默认的CentOS的yum源并不包含pure-ftpd，需要安装epel扩展源，具体过程如下：12# yum install -y epel-release# yum install -y pure-ftpd 2. 配置 pure-ftpd在启动pure-ftpd之前，需要先修改配置文件/etc/pure-ftpd/pure-ftpd.conf。该配置文件里面的内容很多，其中需要修改的是：把PureDB /etc/pure-ftpd/pureftpd.pdb前面的#删除，然后启动pure-ftpd，启动之前需要关闭vsftpd，因为有端口冲突，过程如下所示：123# systemctl stop vsftpd# systemctl start pure-ftpd# ps aux | grep pure-ftp 启动成功的话，ps aux可以看到相关的进程。如果乜有正常启动，需要通过/var/log/messages日志查看原因。 3. 建立账号为了安全，pure-ftp使用的账号并非Linux的系统账号，而是虚拟账号。 首先，创建一个虚拟账号，如下所示：123456# mkdir /data/ftp/# useradd -u 1010 pure-ftp# chown -R pure-ftp:pure-ftp /data/ftp/# pure-pw useradd ftp_user1 -u pure-ftp -d /data/ftp/Password:Enter it again: 说明： -u选项将虚拟用户ftp_user1与系统用户pure-ftp关联再一起，也就是说，使用ftp-user1账号登陆FTP后，会以pure-ftp的身份来读取和下载文件 -d选项后面的目录为ftp_user1账户的家目录，这样可以使ftp_user1只能访问其家目录/data/ftp/ 然后创建用户信息数据库文件，这一步很关键。执行如下命令：pure-pw mkdb 其中，pure-pw还可以列出当前FTP账号以及删除某个账号。例如，我们再创建一个账号，如下所示：12# pure-pw useradd ftp_user2 -u pure-ftp -d /tmp# pure-pw mkdb 列出当前账号，执行如下命令：123# pure-pw listftp_user1 /data/ftp/./ftp_user2 /tmp/./ 如果想删除账号，执行如下命令：1pure-pw userdel ftp_user2 4. 测试pure-ftpd测试过程如下：12345# lftp ftp_user1@172.0.0.1口令：# ls# put /etc/fatab# ls 说明： 登陆后，使用ls可以查看当前目录都有什么文件 使用put命令可以把系统的文件上传到FTP服务器上 你还可以再Windows机器里安装一个FTP客户端软件（推荐开源的FileZilla），然后远程链接测试。 OK","tags":[]},{"title":"Shell脚本基础语法","date":"2017-09-21T11:07:30.000Z","path":"2017/09/21/Shell/002. Shell脚本基础语法/","text":"GO 什么是shell脚本shell脚本在Linux系统管理员的运维工作中非常重要。shell脚本并不能称之为正式的编程语言，因为它是在Linux的shell中运行的，而且它是有一些逻辑语法组合起来的命令的集合，所以称之为shell脚本很贴切。 在运维工作中，自定义的shell脚本建议都放到/usr/local/bin目录下，这样做的好处是，一来可以很方便的管理文档，二来在以后运维工作中，接管你的管理员就会知道自定义脚本都放在了哪里，方便维护。 shell脚本的创建和运行创建一个shell脚本vim hello.sh用编辑器vim即可创建一个空的shell脚本。在其中添加脚本内容：123456#!/bin/bash# HelloWorld!# 创建时间：2017-09-21dateecho \"HelloWorld!\" 说明： shell脚本通常都是以.sh为后缀名。 shell脚本第一行要以#!/bin/bash或#!/bin/sh开头，它俩是相同的，是链接文件。这行内容表示的是该文件使用的是bash语法。 #为注释符，一般在后面填写这样的注释内容：本脚本的功能，创建时间和更新时间，以及作者等相关信息。 运行一个shell脚本运行一个脚本有两种方式： 以bash来执行这个脚本 # sh hello.sh # bash hello.sh # sh -x hello.sh 用-x选项用来查看shell脚本的执行过程，方便debug。 以可执行文件的方式来执行这个脚本 # chmod +x hello.sh 使用这种执行方式要使该脚本文件具有可执行的权限。 ./hello.sh或该文件的绝对路径名称。 date命令date命令常用语shell脚本中。 该命令常用的几个选项如下： date +%Y：表示以四位数字格式打印年份 date +%y：表示以两位数字格式打印年份 date +%m：表示月份 date +%d：表示日期 date +%H：表示小时 date +%M：表示分钟 date +%S：表示秒 date +%w：表示星期几。结果显示0则表示周日 date +%W：表示目前所在星期是一年中的第多少个星期 该命令在shell中最常用的几个选项如下： date +%Y-%m-%d：输出四位的年月日，格式 2017-09-21 date +%y-%m-%d：输出两位的年月日，格式 17-09-21 date +%F：相当于date +%Y-%m-%d date +%H:%M:%S：输出时间，格式 16:22:30 date +%T：等同于上面 date +%s：时间戳 date -d @时间戳：根据时间戳反推出时间 date -d &quot;+1 day&quot; +%d：一天后 date -d &quot;-1 day&quot; +%d：一天前 date -d &quot;-1 hour&quot; +%H：一个小时前 date -d &quot;-1 month&quot; +%m：一个月前 date -d &quot;-1 min&quot; +%M：一分钟前 shell脚本中的变量自定义变量变量的定义和使用定义变量的格式为：变量名=变量的值使用变量时需要在变量前面加上这个符号$ 变量的常用用法反引号的使用使用反引号，可以将一条命令的执行结果赋值给一个变量，如：12d1=`date +F%T`echo \"$d1\" 数学运算shell脚本中变量的数学运算有两种方式，如下： c=$[$a+$b] c=$(($a+$b)) 但是，shell脚本默认是不支持小数的，如果我们需要用到小数，比如保留两位小数点时，我们可以这样来实现：# echo &quot;scale=2;10/3&quot; | bc 和用户交互read命令用于和用户交互，它把用户输入的字符串作为变量值。常用格式为:read &quot;提示的内容：&quot; 变量名 示例脚本如下：123456789#!/bin/bash## Using 'read' in shell script.## Theshu 2017-09-21read -p \"Please input a number: \" xread -p \"Please input another number: \" ysum=$[$x+$y]echo \"The sum of two numbers is: $sum\" 预设变量在shell脚本执行时，后面可以跟一个或多个参数。在shell中有一些预设的变量可以表示这些参数（这些预设的变量从理论上看是没有限制的）。 常用的几个预设变量如下： $#：表示总共有几个参数 $0：表示命令或脚本名本身 $1：表示后面跟的第一个参数 $2：表示后面跟的第二个参数 $n：表示后面跟的第n个参数 示例脚本如下：123456#!/bin/bash# use $1 and $2 # Theshu 2017-09-21sum=$[$1+$2]echo \"sum=$sum\" shell脚本中的逻辑判断if 语句if语句常用于判断某些条件满足时执行哪些语句，不满足时又执行哪些语句。其格式有以下三种。 不带else的if语句格式如下：1234if 判断语句then commandfi 带有else的if语句格式如下：123456if 判断语句then command1else command2fi 带有elif的if语句格式如下：123456789101112if 判断语句1then command1elif 判断语句2then command2......elif 判断语句nthen command(n)else command(n+1) case 语句当有多个判断条件时，除了用带有elif的if语句外，还可以用case语句来实现。 格式如下：123456789101112131415case 变量 in value1) command1 ;; value2) command2 ;; ...... valuen) command(n) ;; *) command(n+1) ;;esac 条件表达式（即判断语句）一个特殊的条件表达式： :表示条件为真 以((条件表达式))来表示判断语句这种格式在判断数值大小时最为方便，比如：((a&gt;60)) 在这种格式下，可以用&lt;、&lt;=、&gt;、&gt;=、==、!=这些数学符号。 以[ 条件表达式 ]来表示判断语句这种格式最为常用，但是这种格式下，不能用那些数学符号来表示数值关系了（除==外）。 在这种格式下，常用的判断符号有： 判断数值大小 -lt：小于 -gt：大于 -le：小于等于 -ge：大于等于 -eq：等于（也可以使用==） -ne：不等于 判断属性的符号 -e：判断文件或目录是否存在 -d：判断是不是目录以及是否存在 -f：判断是不是普通文件以及是否存在 -r：判断是否有读权限 -w：判断是否有写权限 -x：判断是否有执行权限 -z：判断某个变量是否为空 使用if判断时具体的格式如下（例子）： 1234if [ -e filename ]then commandfi 说明： shell脚本中的语句可以以分号结尾，也可以不用分号，不用分号时以换行符结尾 [ 条件表达式 ]这种格式中，中括号和条件表达式之间有空格 条件表达式中，变量名用双引号括起来更加准确，变量名和判断符号之前也要有空格 逻辑运算符逻辑运算符用于判断条件与条件之间的关系。有下面三个： &amp;&amp;：表示并且的意思 ||：表示或者的意思 !：表示非的意思 常用格式：12345[ 条件表达式1 ] &amp;&amp; [ 条件表达式2 ][ 条件表达式1 ] || [ 条件表达式2 ]((条件表达式1)) &amp;&amp; ((条件表达式2))((条件表达式1)) || ((条件表达式2))[ ! 条件表达式 ] 表示不满足该条件时 shell脚本中的循环for循环for循环结构是在日常工作中使用最频繁的循环结构。其格式为：1234for 变量名 in 循环的条件do commanddone 说明： 循环的条件，可以是一组字符或者数字（用一个或多个空格隔开），也可以是一条命令的执行结果（用反引号把命令括起来，如`seq 1 5`表示从1到5的一个序列）。 示例脚本如下（打印出1到5的数字）：1234567#!/bin/bash## use forfor i in `seq 1 5`do echo $idone while循环while循环常用于编写死循环的脚本，用于监控某项服务。其格式为：1234while 条件do commanddone 示例脚本如下：12345678#!/bin/basha=5while [ $a -ge 1 ]do echo $a a=$[$a-1]done 另外可以用一个冒号代替循环条件，表示真，这样可以做到死循环。示例脚本如下：123456#!/bin/bashwhile : do sleep 3done select循环select也是循环的一种，它比较适合在用户选择的情况下。接下来我们用一个例子来说明它的用法。 一个例子比如，我们有这样一个需求，运行脚本后，让用户去选择数字，选择1运行w命令，选择2运行top命令，选择3运行free命令，选择4退出。脚本这样实现： 123456789101112131415161718192021222324#!/bin/bashecho \"Please chose a number, 1:run w, 2:run top, 3:run free, 4:quit\"echo select command in w top free quitdo case $command in w) w ;; top) top ;; free) free ;; quit) exit ;; *) echo \"Please input a number:(1-4).\" ;;esacdone 运行结果如下：1234567891011121314151617# sh select.shPlease chose a number, 1:run w, 2:run top, 3:run free, 4:quit1) w2) top3) free4) quit#? 1 19:41:01 up 13 min, 1 user, load average: 0.00, 0.01, 0.04USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.0.100 19:30 5.00s 0.04s 0.00s w#? 3 total used free shared buff/cache availableMem: 2032156 109500 1791200 8748 131456 1765448Swap: 4194300 0 4194300#? 4# 说明： select默认会把序列号对应的命令列出来，每次输入一个数字，则会执行相应的命令，命令执行完后并不会退出脚本。它会继续让我们再次输入序号。 序号前面的提示符，我们是可以修改的，利用变量PS3即可。 例子改版1利用PS3变量定义序号前的提示符，修改脚本如下：123456789101112131415161718192021222324252627#!/bin/bashPS3=\"Please select a number:\"echo \"Please chose a number, 1:run w, 2:run top, 3:run free, 4:quit\"echo select command in w top free quitdo case $command in w) w ;; top) top ;; free) free ;; quit) exit ;; *) echo \"Please input a number:(1-4).\" ;;esacdone 执行结果如下：1234567891011121314151617# sh select2.shPlease chose a number, 1:run w, 2:run top, 3:run free, 4:quit1) w2) top3) free4) quitPlease select a number:1 19:52:07 up 24 min, 1 user, load average: 0.00, 0.01, 0.04USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.0.100 19:30 7.00s 0.07s 0.00s wPlease select a number:3 total used free shared buff/cache availableMem: 2032156 109496 1791192 8748 131468 1765444Swap: 4194300 0 4194300Please select a number:4# 例子改版2如果想要脚本每次输入一个序号后就自动退出，则需要再次更改脚本如下：123456789101112131415161718192021222324252627#!/bin/bashPS3=\"Please select a number:\"echo \"Please chose a number, 1:run w, 2:run top, 3:run free, 4:quit\"echo select command in w top free quitdo case $command in w) w;exit ;; top) top;exit ;; free) free;exit ;; quit) exit ;; *) echo \"Please input a number:(1-4).\";exit ;;esacdone 执行结果如下：123456789101112# sh select3.shPlease chose a number, 1:run w, 2:run top, 3:run free, 4:quit1) w2) top3) free4) quitPlease select a number:1 19:55:14 up 27 min, 1 user, load average: 0.08, 0.03, 0.04USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 192.168.0.100 19:30 2.00s 0.08s 0.00s w# shell脚本中的函数在shell脚本中也可以使用函数，包括自定义的函数。其格式如下12345function 函数名()&#123; command1 command2&#125; 示例脚本如下：123456789#!/bin/bashfunction sum()&#123; sum=$[$1+$2] echo $sum&#125;sum $1 $2 说明： 函数必须定义在前，使用在后 shell脚本中的控制语句 break语句：break用于结束本层循环 continue语句：continue忽略continue之下的代码，直接进行下一次循环 exit语句：exit 数值用于结束脚本的执行，并向系统返回后面的数值 shell脚本中的数组关于shell脚本中的数组了解即可，因为它不常用。在平时的运维工作中，几乎用不到。但是这个概念还是需要了解一下。 数组定义一对圆括号表示是数组，数组元素用”空格”符号分隔开。123# a=(1 2 3 4 5)# echo $a1 说明； 数组名代表的是数组的首个元素 数组读取 获取数组元素的个数： 1echo $&#123;#a[@]&#125; 读取数组中的某一个元素，数标从0开始，a[0]是第一个元素： 1echo $&#123;a[2]&#125; 打印整个数组的元素： 123echo $&#123;a[*]&#125;或者echo $&#123;a[@]&#125; 数组赋值123456# a[1]=100# echo $&#123;a[*]&#125;1 100 3 4 5# a[5]=100# echo $&#123;a[*]&#125;1 100 3 4 5 100 说明： 直接通过数组名[下标]就可以对其进行赋值 如果下标不存在，自动添加一个新的数组元素 数组的删除123456789# a=(1 2 3 4 5)# unset a# echo $&#123;a[*]&#125;# a=(1 2 3 4 5)# unset a[1]# echo $&#123;a[*]&#125;1 3 4 5# echo $&#123;#a[*]&#125;4 数组分片12345# a=(`seq 1 5`)# echo $&#123;a[@]:0:3&#125; //表示从a[0]开始，依次向后输出3个元素1 2 3# echo $&#123;a[@]:1:4&#125; //表示从a[1]开始，依次向后输出4个元素2 3 4 5 数组替换可用echo替换（并非真正的改变值）：12345# a=(1 2 3 4 5)# echo $&#123;a[@]/3/100&#125;1 2 100 4 5# echo $&#123;a[@]&#125;1 2 3 4 5 可用赋值的方式来替换123# a=($&#123;a[@]/3/100&#125;)# echo $&#123;a[@]&#125;1 2 100 4 5 OK","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.theshu.top/tags/Shell/"}]},{"title":"NFS服务简单配置（Aming）","date":"2017-09-20T14:19:38.000Z","path":"2017/09/20/服务/001. NFS服务简单配置（Aming）/","text":"GO NFS用于在网络上共享存储。 服务端配置NFS安装在CentOS上使用NFS服务需要安装两个包：nfs-utils和rpcbind。在使用yum工具安装nfs-utils时会一并安装rpcbind。如下所示：yum install -y nfs-utils 说明： 以往的CentOS版本是需要安装protmap包的，从CentOS6开始，就改为安装rpcbind包了。 配置配置NFS比较简单，只需要编辑配置文件/etc/exports。如下所示，是一个非常简单的例子，用来创建一个简单的NFS服务器。 首先，修改配置文件（默认该文件为空），如下所示：123# vim /etc/exports //写入如下内容/home/nfstestdir 192.168.188.0/24(rw,sync,all_squash,anonuid=1000,anongid=1000) 说明： 这个配置文件就一行，共分为三个部分 第一个部分是本地要共享出去的目录 第二个部分是允许访问的主机（可以是一个IP，也可以是一个IP段） 第三个部分是小括号里面的一些权限选项 如上例子所示的这条配置的意义是，要共享的目录为/home/nfstestdir，信任的主机为192.168.188.0/24这个网段，权限为读写，同步模式，下限定所有使用者，并且限定的UID和GID都为1000 关于第三部分的权限选项的说明 rw：表示读/写 ro：表示只读 sync：同步模式，表示内存中的数据实时写入磁盘 async：非同步模式，表示把内存中的数据定期写入磁盘 no_root_squash：加上这个选项后，root用户就会对共享目录拥有至高的权限控制，就像是对本机的目录操作一样，但这样安全性降低 root_squash：与no_root_squash选项相对应，表示root拥护对共享目录的权限不高，只有普通用户的权限，即限制了root all_squash：表示不管使用NFS的用户是谁，其身份都会被限定为一个指定的普通用户身份 anonuid/anongid：要和root_squash以及all_squash选项一同使用，用于指定使用NFS的用户被限定后的UID和GID，但前提是本机的/etc/passwd中存在相应的UID和GID 其次，编辑好配置文件后，创建相关目录并启动NFS服务，如下所示：12345# mkdir /home/nfstestdir# systemctl start rpcbind# systemctl start nfs# systemctl enable rpcbind# systemctl enable nfs 说明： 在启动NFS服务之前，需要先启动rpcbind服务（CentOS的老版本中为portmap]） 客户端挂载NFS假设两台机器的IP分别为192.168.188.128和192.168.188.129。其中提供NFS服务的是192.168.188.128，客户端是192.168.188.129。 在客户端挂载NFS之前，需要查看服务端共享了哪些目录。在客户端（188.129）安装nfs-utils包后，可以使用showmount命令查看（这个命令就是前面的包所带的），如下所示：123# showmount -e 192.168.188.128Export list for 192.168.188.128:/home/nfstestdir 192.168.188.0/24 说明： 使用命令showmount -e IP就可以查看NFS的共享情况，这个IP为NFS服务端IP 从上例中可以看到192.168.188.128的共享目录为/home/nfstestdir，信任主机为192.168.188.0/24这个网段。 .然后在客户端上（188.129）挂载NFS，如下所示：123# mount -t nfs -o nfsvers=3 192.168.188.128:/home/nfstestdir /mnt# df -h....... 说明： 使用命令df -h可以看到增加了一个/mnt分区，它就是NFS的共享目录了。 -o后面跟挂载选项，如果不加-o nfsvers=3则在挂载目录下的文件属主和属组都是nobody，如果指定 nfsvers=3 则显示UID和GID，所以尽量加上这个选项，避免权限混乱 假如在该NFS的共享目录里面创建文件的权限不够，则需要在客户端中给共享目录相应的权限（如：chmod 777 /home/nfstestdir） 在权限配置正确后，客户端在NFS共享目录里面创建文件即可成功。（在上例配置的情况下，客户端在NFS共享目录里面创建的文件所有者和所属组的UID和GID都为1000） 命令 exportfs这个命令用于这种情况，当改变NFS的配置文件/etc/exports后，使用该命令挂载而不需要重启NFS服务。 exportfs命令的常用选项为-a、-r、-u和-v，各个选项的含义如下： 常用选项 含义 -a 表示全部挂载或者卸载 -r 表示重新挂载 -u 表示卸载某一个目录 -v 表示显示共享的目录 一个测试实验下面是关于以上知识的一个实验（从上面的例子中继续试验）： 首先修改服务端（188.128）的配置文件，如下所示：123# vi /etc/exports //增加一行：/tmp/ 192.168.188.0/24(rw.sync,no_root_squash) 然后在服务端（188.128）上执行如下命令：123# exportfs -arvexporting 192.168.188.0/24:/tmpexporting 192.168.188.0/24:/home/nfstestdir 在上一节用到了mount命令。用mount命令来挂载NFS服务是有讲究的，它要用-t nfs来指定挂载的类型为nfs。另外在挂载NFS服务时，常用-o nolock选项（即不加锁）。例如在客户端（188.129）上执行如下命令：12# mkdir /aminglinux# mount -t nfs -o nolock 192.168.188.128:/tmp /aminglinux/ 开机自动挂载NFS（基于上面的实验）还可以把要挂载的NFS目录写入到客户端上的/etc/fstab文件中，挂载时只需要执行mount -a命令。例如在/etc/fstab文件中增加一行，如下所示：1192.168.188.128:/tmp/ /aminglinux nfs defualt,nolock 0 0 由于刚刚已挂载了NFS，需要先卸载，执行如下命令：1# umount /aminglinux 然后重新挂载，执行如下命令：1mount -a 说明： 这样操作的好处是以后开机会自动挂载NFS。 刚刚挂载的/aminglinux/目录在服务端设置为了no_root_squash，它并不会限制root用户，也就是说使用root用户创建文件时，跟在客户端本机上创建的一样。 OK","tags":[]},{"title":"读书记录清单-武侠","date":"2017-09-18T15:19:47.000Z","path":"2017/09/18/Reading/000. 读书记录清单-武侠/","text":"已读武侠作品记录 书名 作者 读完日期 一刀倾城 小李飞铲 2014 苍穹神剑 古龙 2014.06.19 月异星斜 古龙 2014.07.20 剑气严霜 古龙 2014.07.20 湘妃剑 古龙 2014.07.22 剑毒梅香 古龙 2014.07.22 孤星传 古龙 2014.07.25 失魂引 古龙 2014.07.28 游侠录 古龙 2014.08.03 护花铃 古龙 2014.09.22 彩环曲 古龙 2014.10.02 残金缺玉 古龙 2014.10.13 飘香剑雨 古龙 2014.10.31 飘香剑雨续 古龙 2014.11.01 剑玄录 古龙 2014.11.04 剑客行 古龙 2015.01.09 浣花洗剑录 古龙 2015.01.20 情人剑 古龙 2015.01.21 大旗英雄传 古龙 2015.01.22 武林外史 古龙 2015.01.24 名剑风流 古龙 2015.01.26 绝代双骄 古龙 2015.02.01 楚留香传奇之血海飘香 古龙 2015.04.18 楚留香传奇之大沙漠 古龙 2015.04.19 楚留香传奇之画眉鸟 古龙 2015.04.21 楚留香续集之鬼恋侠情 古龙 2015.04.21 楚留香续集之蝙蝠传奇 古龙 2015.04.22 楚留香续集之桃花传奇 古龙 2015.04.24 楚留香续集之新月传奇 古龙 2015.04.24 楚留香续集之午夜兰花 古龙 2015.04.27 多情剑客无情剑 古龙 2015.07.06 九月鹰飞 古龙 2015.09.04 欢乐英雄 古龙 2015.09.05 大人物 古龙 2015.09.06 萧十一郎 古龙 2015.09.29 火并萧十一郎 古龙 2015.09.29 流星蝴蝶剑 古龙 2015.10.10 七种武器之长生剑 古龙 2015.10.11 七种武器之碧玉刀 古龙 2015.11.02 七种武器之孔雀翎 古龙 2015.10.11 七种武器之多情环 古龙 2015.11.02 七种武器之霸王枪 古龙 2015.11.03 七种武器之离别钩 古龙 2015.11.04 七种武器之拳头 古龙 2015.11.04 天涯明月刀 古龙 2015.12.15 七杀手 古龙 2015.12.15 剑花烟雨江南 古龙 2015.12.16 三少爷的剑 古龙 2015.12.16 边城浪子 古龙 2015.12.28 血鹦鹉 古龙 2016.01.03 白玉老虎 古龙 2016.01.08 白玉雕龙 古龙 2016.01.08 大地飞鹰 古龙 2016.01.10 陆小凤传奇 古龙 2015.12.17 陆小凤之绣花大盗 古龙 2015.12.18 陆小凤之决战前后 古龙 2015.12.22 陆小凤之阴沟赌坊 古龙 2015.12.23 陆小凤之幽灵山庄 古龙 2015.12.23 陆小凤之凤舞九天 古龙 2015.12.24 陆小凤之剑神一笑 古龙 2015.12.25 圆月弯刀 古龙 2016.02.03 飞刀，又见飞刀 古龙 2016.01.08 英雄无泪 古龙 2016.02.05 七星龙王 古龙 2016.02.09 风铃中的刀声 古龙 2016.02.11 怒剑狂花 古龙 2016.02.16 那一剑的风情 古龙 2016.02.19 边城刀声 古龙 2016.02.19 赌局系列 古龙 2016.02.20 古龙传奇 古龙 2015.12.18 古龙散文集 古龙 2016.01.08 绝不低头 古龙 2016.03.26 菊花的刺 古龙 2016.05.12 闯崆峒 古龙 2016.05.18 铁血红颜 古龙 2016.05.21 丐帮之主 古龙 2016.07.16 碧血洗银枪 古龙 2016.05.21 书剑恩仇录 金庸 2015.06.30 碧血剑 金庸 2016.11.24 射雕英雄传 金庸 2016.12.01 飞狐外传 金庸 2016.12.07 雪山飞狐 金庸 2016.12.09 鸳鸯刀 金庸 2016.12.12 连城诀 金庸 2016.12.15 神雕侠侣 金庸 2016.12.17 倚天屠龙记 金庸 2016.12.20 白马啸西风 金庸 2016.12.20 侠客行 金庸 2016.12.23 笑傲江湖 金庸 2016.12.30 天龙八部 金庸 2017.01.18 鹿鼎记 金庸 越女剑 金庸","tags":[]},{"title":"读书记录清单-科幻","date":"2017-09-18T15:09:50.000Z","path":"2017/09/18/Reading/000. 读书记录清单-科幻/","text":"已读科幻作品记录 书名 作者 读完日期 三体 刘慈欣 2014 球状闪电 刘慈欣 20160224 赡养人类 刘慈欣 20160225 赡养上帝 刘慈欣 20160225 朝闻道 刘慈欣 20160228 带上她的眼睛 刘慈欣 20160225 混沌蝴蝶 刘慈欣 20160225 欢乐颂 刘慈欣 20160225 流浪地球 刘慈欣 20160226 思想者 刘慈欣 20160226 微纪元 刘慈欣 20160226 白垩纪往事 刘慈欣 20160226 地火 刘慈欣 20160226 山 刘慈欣 20160226 全频带阻塞干扰 刘慈欣 20160227 地球大炮 刘慈欣 20160227 吞噬者(诗云前传) 刘慈欣 20160227 诗云 刘慈欣 20160227 坍塌 刘慈欣 20160227 圆圆的肥皂泡 刘慈欣 20160227 魔鬼积木 刘慈欣 20160227 海水高山 刘慈欣 20160227 信使 刘慈欣 20160227 人生 刘慈欣 20160227 命运 刘慈欣 20160227 中国太阳 刘慈欣 20160227 鲸歌 刘慈欣 20160227 乡村教师 刘慈欣 20160227 中国1285 刘慈欣 20160227 镜子 刘慈欣 20160227 纤维 刘慈欣 20160227 超新星纪元 刘慈欣 20160228 拉格朗日墓场 王晋康 20160228 解读生命 王晋康 20160302 水星播种 王晋康 20160305 七重外壳 王晋康 20160305 生存实验 王晋康 20160308 追杀K星人 王晋康 20160309 时间移民 刘慈欣 20160822 北京折叠 郝景芳 20160827 你一生的故事 特德姜 20170221 巴比伦塔 特德姜 20170221 领悟 特德姜 20170222 除以零 特德姜 20170223 蚁生 王晋康 20170929","tags":[]},{"title":"读书记录清单-综合","date":"2017-09-18T14:41:31.000Z","path":"2017/09/18/Reading/000. 读书记录清单-综合/","text":"GO 2013-2014 读书清单 书名 作者 读完日期 钢铁是怎样炼成的 尼古拉 奥斯特洛夫斯基 2013 问教余秋雨 吴拯修 2013 话西游养品性 李文库、钱同 2013 古欧洲之谜 埃里希-冯-丹尼肯 2013 明朝那些事儿（系列） 当年明月 2013 把时间当朋友——运用心智获得解放 李笑来 2014 拆掉思维的墙 古典 2014 平凡的世界 路遥 2014 人生 路遥 2014 一生的忠告 [英]查斯特菲尔德伯爵 20140504 别闹了、费曼先生 [美]R.费恩曼 20140519 你干嘛在乎别人怎么想 [美]R.费恩曼 20140618 诛仙 萧鼎 20140628 罪与罚 [俄]陀思妥耶夫斯基 20140819 匆匆那年 九夜茴 20141013 如果你在就好了：一封用旅途写就的情书 蔻蔻梁 20141022 海上灵光 许嵩 201409 乖，摸摸头 大冰 20141026 三毛流浪记全集（漫画） 张乐平 20141117 天才在左疯子在右 塔塔的死亡 20141117 小王子 [法]圣埃克苏佩里 20141117 撒哈拉的故事 三毛 20141118 遇见未知的自己 张德芬 20141118 七大圣 20141118 鬼吹灯（网络版全集） 天下霸唱 2014 盗墓笔记（全集） 南派三叔 20141129 悟空传 今何在 20141212 镜子：照出你看不见的世界史 爱德华多-加莱亚诺 20141217 草房子 曹文轩 20141230 2015 读书清单 书名 作者 读完日期 新世界：灵性的觉醒 艾克哈特-托尔 20150107 人间 曹俊 20150115 走进风月 袁岳 20150214 走进哈佛的美少女：韩国小姐金娜娜 20150214 成就你一生的100个哲理 卢化南 20150227 重遇未知的自己 张德芬 20150316 他们最幸福 大冰 20150331 遇见心想事成的自己 张德芬 20150406 沉默的大多数 王小波 20150428 成为富人的十一种能力 20150502 追风筝的人 卡勒德胡塞尼 20150429 阿狸：梦之城堡 20150429 情人 [法]玛格丽特-杜拉斯 20150505 挪威的森林 村上春树 20150506 世界尽头与冷酷仙境 村上春树 20150514 舞舞舞 村上春树 20150829 寻秦记 黄易 20150531 DOOM启示录 卡什诺 20150604 人件 TomDeNaro&amp;&amp;TimothyKister 20150616 花千骨 fresh果果 20150621 不抱怨的世界 威尔鲍温 20150626 共产党宣言 20150627 马克思传 萧灼基 20150703 写在人生的边上 钱钟书 20150706 The secret 秘密 郎达拜斯 20150706 菊花与刀 [美]鲁斯-本尼迪克特 20150713 追寻生命的意义 弗兰克尔、何忠强、、杨凡池 20150715 藏海花 南派三叔 20150717 黄河鬼馆 南派三叔 20150726 怒江之战 南派三叔 20150728 大漠苍狼 南派三叔 20150801 沙海 南派三叔 20150803 名家笔下的狗儿们 红孩-编 20150804 雾 巴金 20150808 骆驼祥子 老舍 20150808 少有人走的路 [美]约瑟夫-查斯特罗 20150811 呐喊与彷徨 鲁迅 20150817 编程之道 [美]Carlo Chung 20150819 阿弥陀佛么么哒 大冰 20150929 谁杀了我的牛 卡米洛-克鲁斯 20151008 升级你的大脑 20151017 1988：我想和这个世界谈谈 韩寒 20151017 看见真相的男孩 [英]西里尔-斯科特 20151020 阿米系列 恩里克-巴里奥斯 20151023 上帝咬过的苹果，那些缺陷天才们 梁笑梅 20151118 特斯拉自传 尼古拉特斯拉 20151118 风雨中抱紧自由 周若渠 20151120 马克吐温自传 马克吐温 20151201 另一宇宙来的人 冠玄 20151221 人的一半是外星人一半是地球人 李卫东 20151221 被禁止的科学 J-道格拉斯-凯尼恩 20151221 开动大脑——引爆学习力 苏引华 20151224 江湖异人传 向恺然 20151225 我是个算命先生 易之 20151225 我是个大师123 易之 20151226 苏格拉底的6个问题 克里斯托弗-菲利普斯 20151225 深度学习的艺术 知乎 20151227 火星救援 [美]安迪威尔 20151230 2016 读书清单 书名 作者 读完日期 蓝皮书计划UFO之谜 安克编 20160101 鲁滨逊漂流记 [英]丹尼尔-笛福 20160102 不必读书目 刀尔登 20160102 季羡林：读书与做人 季羡林 20160105 论十大关系 毛泽东 20160105 人生的意义 特里-伊格尔顿 20160109 解忧杂货店 东野圭吾 20160111 岛上书店 加布瑞埃拉-泽文 20160112 再生魔术之女 东野圭吾[短篇] 20160112 寻找时间的人 [爱尔兰]凯特-汤普森 20160114 麦田里的守望者 [美]杰罗姆·大卫·塞林格 20160130 细米 曹文轩 20160202 衣锦夜行 程毅南 20160207 幸福课 动机在杭州 20160207 电脑的秘密 20160216 Into the wild JonKrakauer 20160114 给讨厌数学的人：数学的奥妙和生活 小室直树 20160301 我们聊一聊：15位名人给大学生34封私人信 20160221 知乎周刊：你不是你的性别 20160308 知乎周刊：程序人生 20160308 过得刚好 郭德纲 20160311 老炮儿 管虎、董润年 20160311 一个人的朝圣 蕾秋-乔伊斯 20160314 陪安东尼度过漫长岁月-红橙黄 20160314 一个人的朝圣2：奎妮的情歌 蕾秋-乔伊斯 20160316 皮囊 蔡俊达 20160316 哲学家们都干了些什么 林欣浩 20160322 阿Q正传 鲁迅 20160322 中国缺什么，日本缺什么 近藤大介 20160323 读书这么好的事 张新颖 20160327 30岁之前别结婚 [美]陈愉/著，王剑波/译 20160418 超右脑英语学习法 [日]七田真 20160420 阅读就是魅力 kindle 20160424 二十年目睹怪现状 [清]吴妍人 20160427 信息简史 [美]詹姆斯-格雷克 20160506 最好的我们 八月长安 20160419 牛津通识读本：数学 蒂莫西-高尔斯 20160514 胡萝卜须 [法]列纳尔 著 王振孙 译 20160514 阿甘正传 [美]温斯顿-格卢姆 20160522 舍得让爱你的人受苦 张德芬 20160523 罗素的故事 20160523 活出全新的自己 张德芬 20160524 第三种猩猩-人类的身世和未来 戴蒙德 20160527 瓦尔登湖（译本） 梭罗 20160527 地心游记 [法]儒勒凡尔纳 20160528 七日谈 刀尔登 20160530 蔷薇园 [波斯]萨迪 20160603 只是为了好玩：Linux之父林纳斯自传 20160609 余罪（全8卷） 常书欣 20160624 老人与海 欧内斯特海明威 20160703 黑客与画家 保罗-格雷厄姆 20160710 肖申克的救赎 ［美］史蒂芬·金 20160730 看见 柴静 20160802 男人这东西 ［日］渡边淳一 20160807 八十天环游世界 凡尔纳 20160820 白夜行 东野圭吾 20160825 不抱怨的世界2 威尔鲍勃 20160902 断舍离 20160906 变形记 卡夫卡 20160908 海边的卡夫卡 村上春树 20160911 偷影子的人 马克李维 20160912 新月集 ［印度］泰戈尔 20160912 哈姆雷特 莎士比亚 20160913 人为什么活着 王小波 20160917 白说 白岩松 20160924 黑铁时代 王小波 20160929 死亡通知单（五本） 周浩晖 20160929 人间失格 太宰治 许时嘉 20161014 蒙马特遗书 邱妙津 20161015 无声告白 [美]伍绮诗 20161020 钟形罩 [美]西尔维亚普拉斯 20161027 谁动了我的奶酪 斯宾塞约翰逊 20161028 JT叔叔的理科教室-庄子 20161031 黑笑小说 20161118 蝇王 威廉戈尔丁 20161123 动物凶猛 王朔 20161212 2017 读书清单 书名 作者 读完日期 这一生，只为爱而活 20170305 走在阳光下 龙奔新 20170305 花间一枝禅 释然 20170306 一万小时天才理论 [美]丹尼尔科伊尔 20170405 刘慈欣谈科幻 刘慈欣 20170604 汤姆索亚历险记 马克吐温 20170915 2018 读书清单 书名 作者 读完日期 Ok","tags":[]},{"title":"Shell基础知识","date":"2017-09-02T16:02:20.000Z","path":"2017/09/03/Shell/001. Shell基础知识/","text":"GO 这些内容是在学习Shell脚本之前必须要掌握的Shell基础知识。 Shell 初相识什么是ShellShell 是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。在Shell和计算机硬件中间还有一层东西，那就是系统内核。用户在使用计算机的时候，直接面对的并不是计算机硬件，而是Shell，用户把指令告诉Shell，然后Shell再传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。 Shell的版本有很多，但是初学时所接触的Linux发布版本（RedHat或CentOS系列）默认安装的Shell版本是bash（即Bourne Again Shell），它是sh（Bourne Shell）的增强版本。Bourne Shell是最早流行起来的一个Shell版本。其创始人是Steven Bourne，为了纪念他而将其命名为Bourne Shell，简称sh。 Shell的特性命令记录历史historyhistory：用来查看命令历史列表。 我们执行过的命令bash都会记录，预设可以记录1000条历史命令，这些命令保存在用户的家目录下的 .bash_history 文件中。 需要注意的是，只有当用户正常退出当前Shell时，在当前Shell中运行过的命令才会保存至该文件里。 我们可以自定义命令历史的大小，可以更改在配置文件/etc/profile 中的 HISTSIZE 环境变量。比如我们可以将其更改为2000。 我们也可以设置一下命令历史的记录格式，比如在每条命令前加上其被执行的时间，这时我们应该设置 HISTTIMEFORMAT 环境变量，也是在配置文件 /etc/profile 中进行设置，为了方便查看，可以在 HISTSIZE 下面增加一条：HISTTIMEFORMAT=&quot;%Y/%m/%d %H:%M:%S&quot; 。 我们可以把记录命令历史的文件设置成永久保存的权限，即不允许删除其内容，只能追加：chattr +a ~/.bash_history 。 关于!的几个用法!是与命令历史有关的一个特殊字符，该字符常用的应用有一下几个： !!：连续两个!表示执行上一条命令。 !n：这里的n是数字，表示执行命令历史中的第n条命令。可用命令history查看历史命令列表。 !字符串（字符串大于等于1）：执行最近一次以该字符串开头的命令 !$：使用上一次命令的最后一个参数 命令和文件名补全Tab按键可以补全命令、补全路径或者一个文件名。连续按两次该键会把所有命令或文件名都显示出来。 命令补全 目录补全和文件名补全 命令参数补全 （默认不支持，需要安装一个包：yum install -y bash-comletion，安装后重启系统即可生效） 别名alias 设置别名格式 alias 别名字符串=&#39;所要替代的指令和该指令的参数&#39; 直接执行 alias 会把目前系统预设的别名全部列出来。 别名的配置文件有：~/.bashrc 、 /etc/profile.d/下的脚本里 每个用户可以在自己的配置文件 ~/.bashrc 中加入自定义的别名。 unalias 取消别名格式 unalias 别名字符串 通配符在bash下、可以使用*来匹配零个或多个字符，用?匹配一个字符，[]匹配里面的任一个字符（如 [0-9]），{}表示任取一组。 输入/输出重定向 符号 意义 &gt; 输出重定向 &gt;&gt; 输出追加重定向 &lt; 输入重定向（例子：mail -s &quot;zhuti&quot; somebody@host.com &lt; 邮件内容文件.txt） 2&gt; 错误输出重定向 2&gt;&gt; 错误输出追加重定向 2&gt;&amp;1 相当于 &gt; 1.txt 2&gt; 1.txt 2&gt;&gt;&amp;1 相当于 &gt;&gt; 1.txt 2&gt;&gt; 1.txt &amp;&gt; 把错误和正确的信息重定向到一个文件 &amp;&gt;&gt; 把错误和正确的信息追加重定向到一个文件 管道符管道符|，它用于将前一个指令的标准输出作为后一个指令的参数。 作业控制当运行程序时，可以使它暂停（按Ctrl+Z组合键），然后使用fg（foreground的简写）命令恢复它，或是用bg（background的简写）命令使它到后台运行（或是在运行命令的时候在命令后面加一个&amp;符号）。此外，还可以使它终止运行（按Ctrl+C组合键）。 多个被暂停的任务会有编号，使用jobs命令可以查看到放在后台的任务列表以及它们的编号，ID号后面有+ 或 - ，表示优先级。+比-优先级高。在这时使用bg或者fg命令时，则需要在后面加上编号。若不加编号，默认恢复优先级高的。 如何关掉在后台运行的任务呢？这分两种情况： 如果你没有退出Shell，则应先使用 fg 编号 把任务调到前台，然后按Ctrl+C组合键结束任务。 关闭了当前Shell，再次打开另一个Shell时，使用jobs命令并不会显示在后台运行或者被暂停的任务。要想关闭这些任务，则需要先知道它们的PID。用这个命令 ps aux | grep 关键字 找到这个进程。若是想结束这个进程，需要使用到kill命令。 kill命令很简单，直接在后面加PID即可 kill PID。如果遇到结束不了的进程时，可以在Kill后面加一个选项，即 kill -9 PID。 总结： 命令 意义 Ctrl+Z 暂停任务 fg [编号] 继续任务，把任务调到前台 bg [编号] 把命令调到后台并运行 命令 &amp; 把命令直接丢到后台并运行 jobs 查看进程列表和编号 Ctrl+C 结束当前任务 ps aux 查看相关进程的PID kill [-9] PID 结束进程 变量在Linux系统中预设了很多变量，可以供我们使用。我们也可以自定义一些变量，包括局部变量和全局变量。 echo $变量名 echo $变量名 用于查看一个变量的值。 env env 用于查看系统的全部环境变量。 登陆不同的用户，这些环境变量的值也不同。常见的环境变量如下： 变量名 值的意义 HOSTNAME 主机名 SHELL 当前用户的Shell类型 HISTSIZE 命令历史记录数 MAIL 当前用户的邮件存放目录 PATH 该变量决定了Shell将到哪些目录中寻找命令或程序 PWD 当前目录 LANG 这是与语言相关的环境变量，多语言环境可以修改此环境变量 HOME 当前用户的家目录 LOGNAME 当前用户的登陆名 注意：env命令显示的变量只是环境变量，系统预设的变量其实还有很多，这就需要用到下面的set命令了。 还有两个变需要了解一下： PS1：shell中的提示符 PS2：当在shell中执行换行后再继续操作时的提示符 set 和 unset set 用于查看系统里的全部变量，包括环境变量和用户自定义变量。unset 变量名 可取消或删除一个变量 export 变量名 export 变量名 声明一个变量为全局变量。 自定义变量定义变量的方式 变量=值 只能在当前Shell中使用，不能在子Shell中使用。 export 变量=值 设置了一个全局变量，可以在当前Shell和子Shell中使用。 自定义变量的规则 设定变量的格式为a=b，其中a为变量名，b为变量的值，等号两边不能有空格。 变量名只能由字母、数字以及下划线组成，且不能以数字开头。 当变量内容带有特殊字符时，需要进行特殊处理，如下： 当变量内容带有空格时，需要给该变量加上单引号。如 myname=’Aming Linux’ 当变量内容带有单引号，需要给该变量加上双引号。如 myname=”I’m a cocker” 若变量内容中需要用到其它命令，只使用该命令的运行结果作为变量的值，则该命令需要加上反引号。如 myname=`pwd` 变量内容可以累加其它变量的内容，但需要加双引号。如 myname=”$LOGNAME”Aming b=$a”123” 或 b=$a’123’ c=$a$b a=$a”增加值” 注意单引号、双引号和反引号的使用区别： 单引号：里面的内容全部是普通字符 双引号：里面的内容带有本身的意义，比如某个变量 反引号：里面的内容为一个命名，所代表的是该命令执行之后的结果 让自定义变量一直生效如果想要使自定义的变量一直生效，该如何办到呢？分以下两种情况： 允许系统内所有用户登陆后都可以使用该变量。 在/etc/profile文件的最后一行加入export 变量=值 运行source /etc/profile或. /etc/profile让此配置文件生效 目的达到 仅允许当前用户使用该变量。 在用户家目录下的.bashrc文件的最后一行加入export 变量=值 运行source .bashrc或. .bashrc让配置文件生效 目的达到 变量的配置文件这些配置文件总结如下表： 配置文件名 文件的作用 /etc/profile 到交互登陆时才执行。这个文件预设了几个重要的变量，例如PATH、USER、LOGNAME、MAIL、INPUTRC、HOSTNAME、HISTSIZE、umask等 /etc/bashrc 用户不用登陆，执行shell就生效。这个文件主要预设umask以及PS1 .bash_profile 该文件定义了用户的个人化路径与环境变量的文件名称。每个用户都可以使用该文件输入专属于自己的shell信息，当用户登陆时，该文件仅仅执行一次 .bashrc 该文件包含专属于自己的shell的bash信息，当登陆或每次打开新的shell时，该文件会被读取。例如，用户可以将自己定义的别名或者自定义变量写到这个文件中 .bash_history 该文件用于记录命令历史 .bash_logout 当退出shell时，会执行该文件。可以将一些清理的工作放到这个文件中 PS1变量的说明这个PS1就是我们在输入命令时前面的那串字符。如 [root@AmingLinux-105 ~]#，我们来查看一下PS1的值：12[root@AmingLinux-105 ~]# echo $PS1[\\u@\\h \\W]\\$ 其中，\\u是用户名，\\h是主机名，\\W当前目录名，（\\w表示的是工作目录的完整绝对路径），\\$代表用户身份字符（root为#，普通用户为$） Shell 中的特殊符号特殊符号 特殊符号 意义 * 代表零个或多个任意字符 ? 只代表一个任意字符 # 注释符，这个符号在Linux中表示注释说明，在后面的内容都会被忽略 \\ 脱义字符，将后面的特殊字符还原为普通字符 管道符 将前面命令的输出作为后面命令的输入。支持它的工具有cat、less、head、tail、grep、cut、sort、wc、uniq、tee、tr、split、sed、awk等 $变量名 它可以作为变量前面的标识符 $? 表示上一条的命令执行的返回值，若为0则正确执行，若非零则错误执行 !$ 表示上条命令中的最后一个变量 ; 如果在多条命令中间使用这个符号连接，则表示按顺序依次执行 ~ 代表用户的家目录，用于cd ~ &amp; 表示把命令放到后台执行，用于命令 &amp;；&amp;&amp;代表逻辑与；&amp;1代表参数1 重定向 &gt;、&gt;&gt;、2&gt;、2&gt;&gt;、&lt; 中括号[] 中括号内为字符组合中的任意一个，可以是一个范围（[1-3a-z]） 还有两个符号&amp;&amp;和||，将与;放在一起进行总结： command1 ; command2 不管command1是否执行成功，都会执行command2 command1 &amp;&amp; command2 只有command1执行成功后，才会执行command2 command1 || command2 只有command1执行失败了，才会执行command2 几个常用的管道命令cut cut 用来截取某一个字段。 格式 cut -d &#39;分隔字符&#39; [-cf] n，这里n是数字。其选项说明如下： 选项 说明 -d 后面跟分隔字符，分隔字符要用单引号括起来 -c 后面接的是第几个字符 -f 后面接的是第几个区块 cut命令的用法说明： -d选项后面加冒号作为分隔字符，-f 1 表示截取第一段，-f和1之间的空格可有可无。示例如下： cut -d ‘分隔符’ -f 1 filename cut -d ‘分隔符’ -f 1,2 filename cut -d ‘分隔符’ -f 1-4 filename123456[root@AmingLinux-105 ~]# cat /etc/passwd | cut -d ':' -f 1 | head -5rootbindaemonadmlp -c选项后面可以一个数字n，也可以是一个区间n1-n2，还可以是多个数字n1,n2,n3。示例如下： 123456789101112[root@AmingLinux-105 ~]# head -n2 /etc/passwd | cut -c2oi[root@AmingLinux-105 ~]# head -n2 /etc/passwd | cut -c1rb[root@AmingLinux-105 ~]# head -n2 /etc/passwd | cut -c1-10root:x:0:0bin:x:1:1:[root@AmingLinux-105 ~]# head -n2 /etc/passwd | cut -c1,3,10ro0bn: sort sort 用作排序 格式 sort [-t 分隔符] [-kn1,n2] [-nru]，这里的n1和n2指的是数字，其它选项的含义如下 选项 含义 -t 后面跟分隔字符，作用跟cut的-d选项一样 -n 表示使用纯数字排序 -r 表示反向排序 -u 表示去重复 -kn1,n2 表示由n1区间排序到n2区间，可以只写-kn1，表示只对n1字段排序 sort 命令的用法示例： sort 如果不加任何选项，则从首字符向后依次按ASCII码值进行比较，最后将它们按升序输出。 123456[root@AmingLinux-105 ~]# head -n5 /etc/passwd | sortadm:x:3:4:adm:/var/adm:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinroot:x:0:0:root:/root:/bin/bash -t 选项后面跟分隔符，-k 选项后面跟单个数字表示对第几个区域的字符串排序，-n选项则表示用纯数字排序。 123456[root@AmingLinux-105 ~]# head -n5 /etc/passwd | sort -t: -k3 -nroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin -k 选项后面跟数字n1和n2表示对第n1和n2区域内的字符串排序，-r选项则表示反向排序。 1234567[root@AmingLinux-105 ~]# head -n5 /etc/passwd | sort -t: -k3,5 -rlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologinroot:x:0:0:root:/root:/bin/bash//这里的-k3,5表示对第3区域至第5区域间的字符串排序。 wc wc 用于统计文档的行数、字符数或词数。 常用选项 含义 不加选项 依次输出文档的行数、词数和字符数 -l 统计行数 -m 统计字符数 -w 统计词数 示例命令如下：12345678910[root@AmingLinux-105 ~]# wc /etc/passwd 27 47 1269 /etc/passwd[root@AmingLinux-105 ~]# wc -l /etc/passwd27 /etc/passwd[root@AmingLinux-105 ~]# wc -m /etc/passwd1269 /etc/passwd[root@AmingLinux-105 ~]# wc -w /etc/passwd47 /etc/passwd一个例子（判断文件有几行，如果行数少于3显示no）:line=`wc -l 4.txt|cut -d ' ' -f1` ; if [ $line -lt \"3\" ]; then echo \"no\"; fi uniq uniq 用来删除重复的行 该命令只有-c选项最常用，它表示统计重复的行数，并把行数写在最前面。使用uniq前，必须先给文件排序，否则不管用。示例如下：123456789101112131415161718[root@AmingLinux-105 test]# uniq test.txt11111111111222222222223333333333355555555555[root@AmingLinux-105 test]# sort test.txt | uniq11111111111222222222223333333333355555555555[root@AmingLinux-105 test]# sort test.txt | uniq -c 1 1 11111111111 4 22222222222 2 33333333333 1 55555555555 tee tee 命令类似于重定向&gt;，它的作用是既输出到文件，又输出到屏幕，可以叫它为”双向重定向”。 tee 命令后面跟文件名，且它常用与管道符后面。示例如下：1234[root@AmingLinux-105 test]# echo \"aaaaaaaaaaaaaaaaaaa\" | tee test.txtaaaaaaaaaaaaaaaaaaa[root@AmingLinux-105 test]# cat test.txtaaaaaaaaaaaaaaaaaaa tr tr 用于替换字符，常用来处理文档中出现的特殊符号，如DOS文档中出现的^M。这个工具是针对一个字符来讲的，有一定的局限性。 常用选项 含义 -d 表示删除某个字符，后面跟要删除的字符 -s 表示删除重复的字符 示例如下： tr 常用于把小写字母变成大写字母，如tr &#39;[a-z]&#39; &#39;[A-Z]&#39;。 123[root@AmingLinux-105 test]# head -n2 /etc/passwd | tr '[a-z]' '[A-Z]'ROOT:X:0:0:ROOT:/ROOT:/BIN/BASHBIN:X:1:1:BIN:/BIN:/SBIN/NOLOGIN tr 还可以替换一个字符。 123[root@AmingLinux-105 test]# grep 'root' /etc/passwd | tr 'r' 'R'Root:x:0:0:Root:/Root:/bin/bashopeRatoR:x:11:0:opeRatoR:/Root:/sbin/nologin split split 用于切割文档，常用选项为-b和-l 常用选项 含义 -b 依据大小来分割文档，单位为byte -l 依据行数来分割文档 示例如下：1234[root@AmingLinux-105 test]# cp /etc/passwd .[root@AmingLinux-105 test]# split -b 500 passwd[root@AmingLinux-105 test]# ls1 2 3 4 passwd test.txt test.txt.zip xaa xab xac 如果split不指定目标文件名，则会以xaa、xab、xac….这样的文件名来存储切割后的文件。当然，也可以指定目标文件名。示例如下：12345[root@AmingLinux-105 test]# rm -f xa*[root@AmingLinux-105 test]# split -b 500 passwd new[root@AmingLinux-105 test]# ls1 2 3 4 newaa newab newac passwd test.txt test.txt.zip[root@AmingLinux-105 test]# split -b 1M passwd new 使用-l选项的示例：1234567891011121314151617[root@AmingLinux-105 test]# rm -f new*[root@AmingLinux-105 test]# split -l 10 passwd[root@AmingLinux-105 test]# ls1 2 3 4 passwd test.txt test.txt.zip xaa xab xac[root@AmingLinux-105 test]# wc -l * 0 1 0 2 0 3wc: 4: 是一个目录 0 4 27 passwd 1 test.txt 0 test.txt.zip 10 xaa 10 xab 7 xac 55 总用量 OK","tags":[]},{"title":"Linux软件管理技术","date":"2017-08-31T06:24:42.000Z","path":"2017/08/31/Linux/010. Linux软件管理技术/","text":"GO 0. RPM和DPKG两大阵营在 GNU/Linux( 以下简称 Linux) 操作系统中，RPM 和 DPKG 为最常见的两类软件包管理工具，他们分别应用于基于 RPM 软件包的 Linux 发行版本和 DEB 软件包的 Linux 发行版本。软件包管理工具的作用是提供在操作系统中安装，升级，卸载需要的软件的方法，并提供对系统中所有软件状态信息的查询。 RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。与 RPM 进行竞争的是基于 Debian 操作系统 (UBUNTU) 的 DEB 软件包管理工具－ DPKG，全称为 Debian Package，功能方面与 RPM 相似。 1. CentOS软件管理学习CentOS的软件管理方式，包括RPM包的安装更新查询卸载等，还有源码包的安装方式。 1.1. RPM一个 RPM 包包含了已压缩的软件文件集以及该软件的内容信息（在头文件中保存），通常表现为以 .rpm 扩展名结尾的文件，例如 package.rpm 。对其操作，需要使用 rpm 命令。下面介绍 rpm 工具的参数和使用方法。 1.1.1. RPM 介绍RPM是Red Hat Package Manager的缩写，由RedHat公司开发。它是以一种数据库记录的方式将我们所需要的套件安装到Linux主机的一套管理程序。也就是说，在Linux系统中存在着一个关于RPM的数据库，它记录了安装的包以及包与包之间的依赖关系。RPM包是预先在Linux机器上编译并打包的文件，安装非常快捷。但是它也有一些缺点，比如安装环境必须与编译时一致或相当，包与包之间存在着相互依赖的情况，卸载包时需要先把依赖的包卸载。如果依赖的包是系统所必须的，就不能卸载这个包，否则系统会崩溃。 RPM包的文件名都由-和.分成了若干部分，一般都像这样 abattis-cantarell-fonts-0.0.16-3.el7.noarch.rpm 、abrt-2.1.11-45.el7.centos.x86_64.rpm。abrt为包名，2.11为版本信息，45.el7.centos为发布版本号，x86_64为运行平台。常见的运行平台有i386、i486、i586、i686（这三个为32位的CPU）和x86_64（64位的CPU）。另外，有些RPM包并没有写具体的平台而是noarch，这是该包没有平台限制的意思。 1.1.2. rpm 命令 常用选项 意义 -i 表示安装 -v 表示可视化 -h 表示显示安装进度 -U 表示升级 -e 表示卸载 -q 表示查询 -p 表示对RPM包进行查询，通常和其它参数同时使用 –force 表示强制安装，即使覆盖属于其他包的文件也要安装 –nodeps 表示当要安装（或卸载）的RPM包依赖于其它包时，即使其它包没有安装（或卸载），也要安装（或卸载）这个包 命令 功能 rpm -ivh package.rpm 安装RPM包 rpm -Uvh package.rpm 升级RPM包 rpm -ev package 卸载RPM包（这里的filename是通过RPM的查询功能所查询到的） rpm -q package 查询一个RPM包 rpm -qa (package) 查询当前系统所有已安装的RPM包 rpm -qi package 得到一个已安装的RPM包的相关信息 rpm -ql package 列出一个RPM包的安装文件 rpm -qf 文件的绝对路径 列出某个文件属于哪个RPM包 rpm -qRp package.rpm 查询RPM包的依赖关系 1.1.3. RPM 包管理示例以下步骤描述了一个普通用户安装 IBM Lotus Notes V85 ( 以下简称 Notes) 的典型操作过程。 Notes 的 RPM 包名为 ibm_lotus_notes-8.5.i586.rpm 。 首先查询是否该软件是否已经在系统中存在 : rpm -qa | grep ibm_lotus_notes。如果返回信息为空那么说明该软件还未被安装。 查询 Notes 软件包内容： 12345678910111213# rpm -qip ibm_lotus_notes-8.5.i586.rpm Name : ibm_lotus_notes Relocations: /opt/ibm/lotus/notes Version : 8.5 Vendor: IBM Release : 20081211.1925 Build Date: Sat 13 Dec 2008 09:38:55 AM CST Install Date: (not installed) Build Host: dithers.notesdev.ibm.com Group : Applications/Office Source RPM: ibm_lotus_notes-8.5-20081211.1925.src.rpm Size : 603779427 License: Commercial Signature : DSA/SHA1, Sat 13 Dec 2008 09:43:02 AM CST, Key ID 314c8c6534f9ae75 Summary : IBM Lotus Notes Description : IBM Lotus Notes software provides a robust ... 安装 Notes：rpm -ivh ibm_lotus_notes-8.5.i586.rpm。返回信息如下： 12Preparing... ########################################### [100%] 1:ibm_lotus_notes ########################################### [100%] 升级 Notes：若今后需要基于该版本升级至更高版本的 Notes( 缝 .0 - ibm_lotus_notes-9.0.i586.rpm)，则使用 -U 参数：# rpm -Uvh ibm_lotus_notes-8.5.i586.rpm 卸载 Notes：注意卸载软件使用软件名称，而不是包文件名：# rpm -ev ibm_lotus_notes 1.2. YUM 工具1.2.1. YUM 介绍YUM工具是用来集中管理RPM包的，使用它会更加方便的进行安装卸载升级RPM包。YUM工具最大的优势在于可以联网去下载所需要的RPM包，然后自动安装，若是所安装的RPM包有依赖关系，它会依次安装所依赖的包。 YUM 基于 RPM 包管理工具，能够从指定的源空间（服务器，本地目录等）自动下载目标 RPM 包并且安装，可以自动处理依赖性关系并进行下载、安装，无须繁琐地手动下载、安装每一个需要的依赖包。此外，YUM 的另一个功能是进行系统中所有软件的升级。如上所述，YUM 的 RPM 包来源于源空间，在 RHEL 中由 /etc/yum.repos.d/ 目录中的 .repo 文件配置指定，如 rhel-debuginfo.repo 的内容： rhel-debuginfo.repo123456[rhel-debuginfo] name=Red Hat Enterprise Linux 5Client - i386 - Debug baseurl=ftp://ftp.redhat.com/pub/redhat/linux/enterprise/5Client/en/os/i386/Debuginfo/ enabled=0 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release YUM 的系统配置文件位于 /etc/yum.conf，内容如下：12345678910111213[main] cachedir=/var/cache/yum keepcache=1 debuglevel=2 pkgpolicy=newest logfile=/var/log/yum.log distroverpkg=redhat-release tolerant=1 exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 exclude= firefox gftp 配置文件用来定义用户期望的 yum 行为，比如，gpgcheck 表明安装时不进行 gpg 验证，exclued=firefox gftp 表明进行系统全软件升级时不升级 firefox 和 gftp 。 1.2.2. YUM 命令 命令 功能 yum list 列出所有可用的RPM包资源。（已安装可未安装的都显示出来，yum list会先列出已经安装的包(Installed Packages) 然后再列出可以安装的包(Available Packages)） yum search [关键字] 搜索RPM包（还可以利用 grep 来过滤） yum install [-y] RPM包名 安装RPM包。加上-y选项，表示自动安装，跳过交互的程序 yum remove [-y] RPM包名 卸载RPM包（注意，卸载时最好不要加-y选项，以免重要的RPM包被卸载掉） yum check-update 列出系统中可升级的所有软件 yum update [-y] RPM包名 升级RPM包 yum -y update 升级所有包，改变软件设置和系统设置,系统版本内核都升级 yum -y upgrade 升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变 yum provides 命令名 查询该命令是由那个包安装的 yum grouplist 列出所有安装过和未安装过的套件 yum groupinstall 套件名 安装该组件套件 yum groupremove 套件名 卸载该组件套件 1.2.3. 安装YUM扩展源 我们使用 yum 安装 rpm 包时，经常遇到一些包没有，这时候你可以尝试安装 epel 的扩展源，这里有很多系统不自带的 rpm 包。 yum install -y epel-release yum list 你会发现最右侧出现很多 epel 的 rpm 包。 下载一个扩展源的rpm包，用yum安装。然后用 yum clean all 或 yum makecache 清除缓存，用 yum list 检查是否成功。 1.2.4. 使用本地光盘制作YUN源有时候，Linux系统不能联网，此时当然就不能很便捷地使用联网的yum源了，这时就需要我们自己在Linux系统下使用光盘制作yum源。具体操作步骤如下： 挂载光盘mount /dev/cdrom /mnt 删除/etc/yum.repos.d目录下所有的repo文件（删除之前，最好先做一下备份）。cp -r /etc/yum.repos.d /etc/yum.repos.d_bakrm -rf /etc/yum.repos.d/* 创建新文件dvd.repo，并添加如下内容： 123456# vim /etc/yum.repos.d/dvd.repo[dvd]name=install dvdbaseurl=file:///mntenabled=1gpgcheck=0 刷新repos生成缓存，如下所示：yum makecache 然后就可以用yum了。若需要恢复之前的yum源，则进行如下操作：123# rm -rf /etc/yum.repos.d# mv /etc/yum.repos.d_bak /etc/yum.repos.d# yum list //这一步是必须要执行的，这样就可以生成缓存，方便下次使用 1.2.5. 利用YUM工具下载RPM包有时我们需要下载RPM包但不安装，而仅仅是复制给其它机器使用。我们可以用YUM工具来完成这个任务，做到只下载而不安装。命令如下： 安装 yum-downloadonly（首先需要安装一个插件来支持只下载不安装）yum install -y yum-plugin-downloadonly.noarch（如果你的 CentOS 是 5.x 版本，则需要安装 yum-downloadonly.noarch 这个包。） 只下载而不安装RPM包 yum install 包名 -y --downloadonly （这样虽然下载了，但是并没有保存到我们想要的目录下，它默认保存到了/var/cache/yum/后面还有好几层子目录，根据你系统的版本决定。） 把RPM包下载到指定目录 yum install 包名 -y --downloadonly --downloaddir=绝对路径 下载一个已安装过的RPM包 yum reinstall 包名 -y --downloaonly [--downloddir=绝对路径] 2. Ubuntu软件管理2.1. DEB2.1.1. DEB 介绍一个 DEB 包包含了已压缩的软件文件集以及该软件的内容信息（在头文件中保存），通常表现为以 .deb 扩展名结尾的文件，例如 package.deb 。对其操作，需要使用 dpkg 命令。下面介绍 dpkg 工具的参数和使用方法。 2.1.2. dpkg 命令DPKG 的常规使用方法为 dpkg -? Package(.rpm), 其中 -? 为安装参数 ( 更多信息，请查阅帮助 $man rpm)。 参数 意义 -l 在系统中查询软件内容信息 –info 在系统中查询软件或查询指定rpm包的内容信息 -i 在系统中安装/升级软件 -r 在系统中卸载软件，不删除配置文件 -P(大) 在系统中卸载软件以及其配置文件 depk命令参数使用方法 命令 意义 dpkg -i package.deb 安装或升级DEB包命令 dpkg -r package.deb 卸载DEB包，但是不删除其配置文件 dpkg -P package.deb 卸载DEB包，并且删除其配置文件 dpkg-deb -c package.deb 查询DEB包中包含的文件列表命令 dpkg –info package.deb 查询DEB包中包含的内容信息命令 dpkg -l package 查询系统中所有已安装DEB 2.1.3. DEB 包管理示例以下步骤描述了一个普通用户安装 IBM Lotus Notes V85 ( 以下简称 Notes) 的典型操作过程。 Notes 的 DEB 包名为 ibm_lotus_notes-8.5.i586.deb。 首先查询是否该软件是否已经在系统中存在：dpkg -l ibm-lotus-* 如果系统中从未安装过 Lotus 产品，那么返回信息为 : No pakcages found matching ibm-lotus-* 如果系统安装过 Lotus 产品，但已被删除，那么返回信息为 : pn ibm-lotus-notes none (no description available) 查询 Notes 软件包内容：dpkg --info ibm_lotus_notes-8.5-i586.deb。返回信息如下： 123456789101112new debian package, version 2.0. size 335012296 bytes: control archive= 231821 bytes. ... Package: ibm-lotus-notes Version: 8.5-20081211.1925 Section: IBM Priority: extra Architecture: i386 Installed-Size: 619444 Maintainer: IBM Lotus Product Description: IBM Lotus Notes IBM Lotus Notes software provides a robust ... ... 安装 Notes : dpkg -i ibm_lotus_notes-8.5.i586.deb。返回信息如下： 12345(Reading database ... 151150 files and directories currently installed.) Preparing to replace ibm-lotus-notes 8.5-20081211.1925 (using ibm-lotus-notes-higher-version.i586.deb) ... Unpacking replacement ibm-lotus-notes ... Setting up ibm-lotus-notes (higher-version) ... 升级 Notes：dpkg -i ibm_lotus_notes-8.5.i586.deb。返回信息如下： 12345(Reading database ... 151150 files and directories currently installed.) Preparing to replace ibm-lotus-notes 8.5-20081211.1925 (using ibm-lotus-notes-higher-version.i586.deb) ... Unpacking replacement ibm-lotus-notes ... Setting up ibm-lotus-notes (higher-version) ... 卸载 Notes : 注意卸载软件使用软件名称，而不是包文件名：dpkg -P ibm-lotus-notes 2.2. APT工具2.2.1. APT 介绍APT 的全称为 Advanced Packaging Tools 。与 YUM 对应，它最早被设计成 DPKG 的前端软件，现在通过 apt-rpm 也支持 rpm 管理。而本节本节将介绍 APT 作为 DPKG 前端的使用。 APT 的主要包管理工具为 APT-GET，通过此工具可满足和上述 YUM 相似的功能要求。 APT 的软件源定义来自 /etc/apt/sources.list 文件：1234# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution. deb http://cn.archive.ubuntu.com/ubuntu/ hardy main restricted deb-src http://cn.archive.ubuntu.com/ubuntu/ hardy main restricted 注意每次手动修改上述文件后，需要使用 sudo apt-get update 来更新系统的源使新的源数据被当前系统识别。 Ubuntu 中 APT 的配置文件位于 /etc/apt/apt.conf.d，其中的多个配置文件依功能分类。 2.2.2. APT 命令 命令 意义 apt-get update 更新源索引 apt-get install package-name 安装指定软件 apt-get source package-name 下载指定软件的源文件 apt-get upgrade 将系统中所有软件升级到最新版本 apt-get dist-upgrade 将操作系统连同所有软件升级到最新版本 apt-get remove package-name 卸载指定软件 3. RPM与DEB的一些常见问题3.1. 查询软件包依赖关系查询 RPM 包的依赖关系，使用 rpm -qRp：1234567# rpm -qRp package_a.rpm package_b = version_info 或 package_b &gt;= version_info 或 package_b &lt;= version_info 表明 package_a.rpm 依赖于 version_info 版的 package_b，或者任何高于并包括 version_info 版的 package_b，亦或低于或包括 version_info 版的 package_b 。所以 package_b.rpm 必须在 package_a 之前安装于系统中。 查询 DEB 包的依赖关系，可解读 dpkg –info 结果中的 Pre-Depends 字段：12345678910$ dpkg --info package_a.deb Pre-depends: package_b (= version_info) Depends: package_b (= version_info) 或 Pre-depends: package_b (&gt;= version_info) Depends: package_b (&gt;= version_info) 或 Pre-depends: package_b (&lt;= version_info) Depends: package_b (&lt;= version_info) 表明 package_a.deb 依赖于 version_info 版的 package_b 或者任何高于并包括 version_info 版的 package_b 亦或低于或包括 version_info 版的 package_b. 所以 package_b.deb 必须在 package_a 之前安装于系统中。 所以正确的安装方法如下所示： 对于 package_a，正确的安装方法应该是：1234567##RPM # rpm -ivh package_b.rpm # rpm -ivh package_a.rpm ##DEB $ sudo dpkg -i package_b.deb $ sudo dpkg -i package_a.deb 如上示例为最理想的依赖关系，实际应用中往往最令用户头疼的是 package_a 依赖于 package_b/c/d/e/f 等多个包 , 而 package_b/c/d/e/f 等包又依赖于 package_b1,b2,b3/c1,c2/d1,d2/e1,e2/f1,f2 等等 … … 为保证软件的正常使用，必须找到所有依赖包以及子依赖包并且安装。过多的依赖关系大大降低了 Linux 软件安装的用户友好性。所以针对此类问题，使用了更高级的包管理策略去解决 - yum/apt 。 3.2. RPM 与 DEB 的兼容 - AlienAlien 工具可以将 RPM 软件包转换成 DEB 软件包，或把 DEB 软件包转换成 RPM 软件包，以此适应兼容性的需要。注意首先请在系统中安装 alien 。 在 UBUNTU 中使用 alien 将 rpm 转换为 deb 并安装 :12$ sudo alien -d package.rpm $ sudo dpkg -i package.deb 在 RHEL 中使用 alien 将 deb 转换为 rpm 并安装 :12# alien -r package.deb # rpm -ivh package.rpm 3.3. 常见的一些问题3.3.1. 可以手动强制不进行 RPM/DEB 的依赖性关系检查吗？ RPM：可以。使用 –nodeps 辅助参数，则安装过程将不理会依赖性关系限制，强制安装目标包，如：rpm -i --nodeps package_a.rpm DEB：可以。使用— force-depends 辅助参数，如：dpkg -i --force-depends package_a.deb 3.3.2. RPM 中的 –force 是干什么用的？RPM 中的默认安装规则是不允许同一个包多次安装的，也不允许降级安装。使用 –force 辅助参数将不考虑以上因素，强制安装 RPM 包。但是，–force 无法强制安装一个不满足系统依赖性关系的包 ( 此时需要用到 –nodeps 参数 ) 。使用方法如：rpm -i --force package_a.rpm 3.3.3. RPM/DPKG 支持远程安装吗？ RPM：是。 RPM 支持 HTTP 和 FTP 协议，如：rpm -Uvh ftp://user:pass@ftpserver/package.rpm DEB：最新的基于 DEB 包的系统中，远程安装通常被更先进的 APT 代替。 3.3.4. 可以从 RPM/DPKG 中抽取个别文件吗？ RPM：是。可以使用 rpm2cpio 工具来提取文件 DEB：是。可以使用 dpkg-deb 工具来提取文件：dpkg-deb --extract ibm_lotus_notes-8.5.i586.deb $dir( 目标目录 ) 3.3.5. RPM/DPKG 提供包安装成功的验证机制吗？ RPM：是。可以使用 -V 参数进行验证。 DEB：Debian 系统通常使用 debsums 工具参数进行验证。 3.3.6. RPM/DPKG 提供包安全签名吗？ RPM：是。可以使用 –import 导入与软件同时发布的 GPG KEY, 接着使用 -K 命令来验证包的安全性，如： 1234# rpm --import pub_ibm_lotus_notes.gpg # rpm -K ibm_lotus_notes-8.5.i586.rpm 返回信息 : ibm_lotus_notes-8.5.i586.rpm: (sha1) dsa sha1 md5 gpg OK DEB：DPKG 不提供原生的 Key 验证机制。可以使用 debsigs 和 debsigs-verify 3.3.7. 如果 RPM 的底层数据库损坏，RPM 还能使用吗？ RPM：如果底层数据库损坏，RPM 将无法正常使用。此时最常用的解决方法是重构数据库：rm -f /var/lib/rpm/__* ; rpm -vv --rebuilddb DEB：DPKG 本身不提供底层数据库恢复机制。它的数据库以文件形式保存在 /var/lib/dpkg 目录中。及时地备份这个目录是最好的预防数据库损坏措施。 3.3.8. 可以查询系统中已经安装的某个文件属于哪个 RPM 包吗？ RPM：可以。使用 -qf 参数 , 如在安装了 Notes8.5 的系统中：rpm -qf /opt/ibm/lotus/notes/notes；返回信息 : Ibm_lotus_notes-8.5-20081211.1920 DEB：可以。使用— search 参数 , 如在安装了 Notes8.5 的系统中：dpkg --search /opt/ibm/lotus/notes/notes；返回信息 : ibm-lotus-notes: /opt/ibm/lotus/notes/notes 3.3.9. 可以查询 RPM 包的安装时间吗？ RPM：可以。可使用 –last 查询。如：rpm -qa --last；返回信息 : 系统中所有软件的安装时间。 DEB：DPKG 不提供直接的查询参数，但是可以用过查询 dpkg 的日志文件实现这个功能。如：cat /var/log/dpkg.log | grep &quot;\\ install\\ &quot; 4. 源码包安装在Linux下安装源码包是最常用的。安装源码包，需要我们把源代码编译成可执行的二进制文件。如果你能读懂这些源代码，就可以修改这些源代码的自定义功能，然后按你的需求编译。使用源码包除了可以自定义修改源代码外，还可以定制相关的功能，因为源码包在编译时可以附加额外的选项。 源码包的编译用到了Linux系统里的编译器。常见的源码包一般都是用C语言开发的，因为C语言是Linux上最标准的程序语言。Linux上的C语言编译器称为gcc。利用它可以把C语言编译成可执行的二进制文件。所有，如果Linux上没有安装gcc，就无法编译源码。可以使用命令yum install -y gcc来完成安装。 4.1. 源码包安装的一般步骤安装源码包通常需要以下三个步骤： ./configure。这一步可以定制功能，加上相应的选项即可，具体有什么选项可以通过命令./configure --help来查看。（一般常用的有–prefix=PREFIX这个选项的意思是定义软件包安装到哪里）这一步会自动检测你的Linux系统与相关的套件是否有编译该源代码包时所需要的库，因为一旦缺少某个库，就不能完成编译，所以若是遇到这种情况，要先安装这些库。只有检测通过后，才会生成Makefile文件。 make。使用这个命令，会根据Makefile文件中预设的参数进行编译，这一步其实就是gcc在工作了。 make install。这一步是安装步骤，用于创建相关软件的存放目录和配置文件。 注意，对于以上这3个步骤，并不是所有的源代码包软件都一样，也就是说，源码包的安装并没有标准的安装步骤。这就需要你在拿到源码包解压后，进入目录，找到相关的帮助文档（通常，会以INSTALL或README为文件名）。 通常，源码包都会放置在/usr/local/src目录下，方便对源码包的统一管理。 4.2. 一个源码包安装的实例（安装Apache） 下载源码包 cd /usr/local/src/ #约定目录 wget http://mirrors.cnnic.cn/apache/httpd/httpd-2.2.27.tar.bz2 解压 tar jxvf httpd-2.2.27.tar.bz2 //查看README或者INSTALL说明文件 指定编译参数 ./configure --help ./configure --prefix 安装路径 …… echo $? 验证是否成功 make echo $? 验证是否成功 make install OK","tags":[]},{"title":"Linux压缩打包技术","date":"2017-08-31T06:24:03.000Z","path":"2017/08/31/Linux/009. Linux压缩打包技术/","text":"GO 1. 常见压缩包后缀名及对应工具 后缀名 所使用的压缩工具 .gz gzip .bz2 bzip2 .zip zip .rar rar .tar tar打包程序打包的文件 .tar.gz 先由tar打包，再由gzip压缩 .tar.bz2 先由tar打包，再由bzip2压缩 .tar.xz 先由tar打包，再由xz压缩 2. 常用压缩工具2.1. gzip格式 gzip [-d#] filename（其中#为1~9的数字） 选项 说明 -d 解压 -# 设定压缩等级1为最差，9为最好，6为默认 说明： gzip后面直接跟文件名，表示在当前目录下压缩该文件，而源文件也会消失。 gzip -d \\*.gz 命令gzip -d后面跟压缩文件表示解压缩该压缩文件。解压后源文件会消失。 gunzip filename.gz 解压文件为源文件，不保留压缩文件 gzip 不支持压缩目录，压缩目录时会报错。 关于-#选项，平时很少用到，使用默认压缩级别就够了。 2.2. bzip2格式 bzip2 [-dz] filename 选项 说明 -z 压缩不加该选项也是表示压缩文件 -d 解压缩 说明： 该命令只有-z和-d两个常用选项。 压缩或解压后源文件会消失。 它的压缩级别有1~9，默认级别是9。 bzip2 不可以压缩目录，压缩目录会报错。 2.3. xz格式 xz [-dz] filename 选项 说明 -z 压缩不加该选项也是表示压缩文件 -d 解压缩 说明： 该命令常用的只有-z和-d两个常用选项。 压缩或解压后源文件会消失。 xz 不可以压缩目录，压缩目录会报错。 2.4. zip 和 unzipzip 压缩包非常常见，在Linux里，zip可以压缩目录和文件。压缩目录时，需要指定目录下的文件。 格式： zip filename.zip filename 把文件filename压缩为filename.zip，且保存源文件filename zip -r dir.zip dir 把目录dir压缩为dir.zip，原目录保存（注意，若是目录中有软连接会把链接的原文件也压缩） 示例如下：12345678# zip test.txt.zip test.txt adding: test.txt (deflated 63%) zip test.zip test/* adding: test/1 (stored 0%) adding: test/2 (stored 0%) adding: test/3 (stored 0%) adding: test/test.txt (deflated 63%) adding: test/test.txt.zip (stored 0%) 说明： zip后面先跟目标文件名，即压缩后的自定义压缩包名，然后跟要压缩的文件或目录。 若CentOS没有这个命令，要安装一下：yum install -y zip unzip 当目录下还有二级目录甚至更多级目录是，zip命令仅仅是把二级目录本身压缩而已。如果想要一并压缩二级下的目录，必须加上-r选项，这样就不用加/*了。如下所示：1234567891011# zip -r tests.zip test/ adding: test/ (stored 0%) adding: test/test.txt (deflated 63%) adding: test/test.txt.zip (stored 0%) adding: test/1 (stored 0%) adding: test/2 (stored 0%) adding: test/3 (stored 0%) adding: test/4/ (stored 0%) adding: test/4/5 (stored 0%) adding: test/4/6 (stored 0%) adding: test/4/7 (stored 0%) unzip 是用于解压缩.zip格式文件的，unzip 1.txt.zip解压file.zip文件到当前目录下，且原压缩文件file.zip不会消失。 选项 说明 -l 可查看文件的清单 -d dir 解压到指定目录下 2.5. 查看压缩文件的命令 命令 作用 zcat 查看gzip压缩的文件的内容 bzcat 查看bzip2压缩的文件内容 2.6. tar tar 是一个打包工具，可以把目录打包成一个文件，它把所有文件整合成一个大文件，方便复制或者移动。 格式 tar [-zjxcvfpP] filename.tar 要打包的文件1 要打包的文件2 …… 常用选项 选项说明 -z 同时用gzip压缩 -j 同时用bzip2压缩 -J 同时用xz压缩 -x 解包或解压缩 -t 查看tar包里的文件 -c 建立一个tar包或者压缩文件包 -v 可视化 -f filename 表示压缩后的文件名为filename，或者解压文件filename需要注意的是，如果是多个参数组合的情况，要把-f选项写到最后面） -C dir 在解压解包时使用，解压到指定目录下 -u newfile 在之前的包的基础上更新新的文件到包里 -p小写 使用源文件的属性，压缩前什么属性压缩后还是什么属性（不常用） -P大写 可以使用绝对路径（不常用） –exclude filename 在打包或压缩时，不要将filename文件包括在内。支持通配符。 如：--exclude &quot;*.sh&quot; 将*.sh文件过滤掉不打包（不常用）（不常用） 一些常用的例子： 打包 ： tar -cvf test.tar test1 test2 解包 ： tar -xvf test.tar 打包时排除 ： tar -cvf test.tar --exclude 1.txt test3 查看包或压缩包的文件列表 ： tar -tf test.tar或test.tar.gz等 打包的同时使用gzip压缩 打包压缩： tar -zcvf test.tar.gz test 解包解压缩： tar -zxvf test.tar.gz 打包的同时使用bzip2压缩 打包压缩： tar -jcvf test.tar.bz2 test 解包解压缩： tar -jxvf test.tar.bz2 打包的同时使用xz压缩 打包压缩： tar -Jcvf test.tar.xz test 解包解压缩： tar -Jxvf test.tar.xz OK","tags":[]},{"title":"Linux磁盘管理技术","date":"2017-08-31T06:23:34.000Z","path":"2017/08/31/Linux/008. Linux磁盘管理技术/","text":"GO 这一章学习：如何分区、如何格式化、如何挂载、如何卸载。 0. MBR和GPT0.1. MBRMBR全称Master Boot Record，中文叫做“主引导记录”，又叫做“主引导扇区”，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的地址为0柱面0磁道1扇区。MBR 的主要作用是检查分区状态，寻找活动分区，并将控制权交给活动分区引导记录DBR，再由分区引导程序加载操作系统。标准MBR的结构如下： 主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。MBR是由分区程序所产生的，它不依赖任何操作系统，而且硬盘引导程序也是可以改变的，从而能够实现多系统引导。 硬盘分区表占据主引导扇区的64个字节(偏移0x01BE至偏移0x01FD)，可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。具体每个字节的定义可以参见硬盘分区结构信息： 结束标志字0x55和0xAA是主引导扇区的最后两个字节，是检验主引导记录是否有效的标志。 0.2. GPT0.2.1. GPT概述全局唯一标识分区表（GUID Partition Table，缩写：GPT）是一个实体硬盘的分区结构。它是可扩展固件接口标准的一部分，用来替代BIOS中的主引导记录分区表。 传统的主启动记录 (MBR) 磁盘分区支持最大卷为 2.2 TB (terabytes) ，每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）。 与MBR 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节 (exabytes，1EB=10^6TB) 的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID)。 与 MBR 分区的磁盘不同，GPT的分区信息是在分区中，而不象MBR一样在主引导扇区。为保护GPT不受MBR类磁盘管理软件的危害，GPT在主引导扇区建立了一 个保护分区 (Protective MBR)的MBR分区表，这种分区的类型标识为0xEE，这个保护分区的大小在Windows下为128MB，Mac OS X下为200MB，在Window磁盘管理器里名为GPT保护分区，可让MBR类磁盘管理软件把GPT看成一个未知格式的分区，而不是错误地当成一个未分 区的磁盘。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 在MBR硬盘中，分区信息直接存储于主引导记录(MBR)中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。跟现代的MBR一样，GPT也使用逻辑区块地址（LBA）取代了早期的CHS寻址方式。传统MBR信息存储于LBA 0，GPT头存储于LBA 1，接下来才是分区表本身。64位Windows操作系统使用16,384字节（或32扇区）作为GPT分区表，接下来的LBA 34是硬盘上第一个分区的开始。为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本。与主启动记录 (MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区ID(GUID)。 0.2.2. GPT结构 0.2.3. 传统MBR（LBA 0）在GPT分区表的最开头，处于兼容性考虑仍然存储了一份传统的MBR，用来防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据，这个MBR也叫做保护MBR。在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作，除非用户特别要求删除这个分区。这就避免了意外删除分区的危险。另外，能够识别GPT分区表的操作系统会检查保护MBR中的分区表，如果分区类型不是0xEE或者MBR分区表中有多个项，也会拒绝对硬盘进行操作。 在使用MBR/GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。如Boot Camp就是使用这种方式启动Windows。 0.2.4. 分区表头（LBA 1）分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。在使用64位Windows Server 2003的机器上，最多可以创建128个分区，即分区表中保留了128个项，其中每个都是128字节。（EFI标准要求分区表最小要有16,384字节，即128个分区项的大小） 分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA 1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。所以GPT硬盘的分区表不可以直接使用16进制编辑器修改。 分区表头的格式如下： 起始字节 所占长度 内容 0 8字节 签名（”EFI PART”, 45 46 49 20 50 41 52 54） 8 4字节 修订（在1.0版中，值是 00 00 01 00） 12 4字节 分区表头的大小（单位是字节，通常是92字节，即 5C 00 00 00） 16 4字节 分区表头（第0－91字节）的CRC32 校验，在计算时，把这个字段作为0处理，需要计算出分区串行的CRC32校验后再计算本字段 20 4字节 保留，必须是0 24 8字节 当前LBA（这个分区表头的位置） 32 8字节 备份LBA（另一个分区表头的位置） 40 8字节 第一个可用于分区的LBA（主分区表的最后一个LBA+1） 48 8字节 最后一个可用于分区的LBA（备份分区表的第一个LBA-1） 56 16字节 硬盘GUID（在类UNIX 系统中也叫UUID） 72 8字节 分区表项的起始LBA（在主分区表中是2） 80 4字节 分区表项的数量 84 4字节 一个分区表项的大小（通常是128） 88 4字节 分区串行的CRC32校验 92 * 保留，剩余的字节必须是0（对于512字节LBA的硬盘即是420字节） 主分区表和备份分区表的头分别位于硬盘的第二个扇区（LBA 1）以及硬盘的最后一个扇区。备份分区表头中的信息是关于备份分区表的。 0.2.5. 分区表项（LBA 2-33）GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。 GPT分区表项的格式如下： 起始字节 所占长度 内容 0 16字节 分区类型GUID 16 16字节 分区GUID 32 8字节 其实LBA（小端序） 40 8字节 末尾LBA 48 8字节 属性标签（如：60表示“只读”） 56 72字节 分区名（可以包括36个UTF-16（小端序）字符） 1. 查看磁盘或目录的容量监控磁盘的使用率在日常的监控工作中是必须要做的。 1.1. df df （disk filesystem）用于查看已挂载磁盘的总容量、使用容量、剩余容量等。 常用选项 选项说明 不加选项 默认以KB为单位显示 -i 查看inodes的使用状况，如已使用100%，即使磁盘空间有富余，也会提示磁盘空间已满 -h 以合适的单位显示 -k 以KB为单位显示（默认） -m 以MB为单位显示 -T 查看每个分区的文件系统类型 示例：1234567891011121314151617181920# df文件系统 1K-块 已用 可用 已用% 挂载点/dev/sda3 16561152 3760600 12800552 23% /devtmpfs 1006276 0 1006276 0% /devtmpfs 1016076 0 1016076 0% /dev/shmtmpfs 1016076 8796 1007280 1% /runtmpfs 1016076 0 1016076 0% /sys/fs/cgroup/dev/sdb5 991512 2516 921412 1% /newdir/dev/sda1 201380 95320 106060 48% /boottmpfs 203216 0 203216 0% /run/user/0df -h文件系统 容量 已用 可用 已用% 挂载点/dev/sda3 16G 3.6G 13G 23% /devtmpfs 983M 0 983M 0% /devtmpfs 993M 0 993M 0% /dev/shmtmpfs 993M 8.6M 984M 1% /runtmpfs 993M 0 993M 0% /sys/fs/cgroup/dev/sdb5 969M 2.5M 900M 1% /newdir/dev/sda1 197M 94M 104M 48% /boottmpfs 199M 0 199M 0% /run/user/0 该命令所显示的内容中，每列所代表的意义如下： 列数 意义 第一列 分区的名字 第二列 该分区的总容量 第三列 已使用容量 第四列 可用的剩余容量 第五列 使用容量的百分比（若该数值达到90%以上，就需要进行管理了） 第六列 分区的挂载点 该命令所显示的内容中，挂载点的说明： /dev和//dev/shm 为内存分区，默认大小为内存的1/2，如果我们把文件存在这个分区下，相当于存在了内存中，好处是读写速度非常快，坏处是系统重启时文件会丢失。 /run、/sys/fs/cgroup等分区都是tmpfs，跟/dev/shm类似，为临时文件系统，最好不要碰它们 1.2. du du （disk useage）用来查看某个目录或文件所占空间的大小。 格式 du [-abckmsh] [文件或目录名] 常用选项 选项说明 不加参数 只会列出目录（包含子目录）的大小。默认单位为KB -a 表示全部文件和目录的大小都列出来 -b 以B为单位输出 -k 以KB为单位输出 -m 以MB为单位输出 -h 自动以合适的单位输出 -c 表示最后加总（不常用） -s 只列出总和（用的最多） 说明：这个命令用的最多的情况是这种形式： du -sh filename 2. 磁盘的分区2.1. fdiskfdisk 是Linux下硬盘的分区工具，是一个非常实用的命令，但是fdisk只能划分小于2TB的分区。大于2T的用parted命令。注意，分区是非常危险的操作，操作失误很可能会把数据弄丢，所以一定要高度警惕！ 格式 fdisk [-l] 设备名称 说明： fdisk 的选项只有-l这一个。 选项-l的后面不加设备名称，会直接列出系统中所有的磁盘设备以及分区表。 选项-l的后面加上设备名称，则会列出该设备的分区表。 fdisk -l 显示系统能够识别到的硬盘有哪些，每个硬盘的分区有哪些（类似 /dev/sda，/dev/sdb 等，和/dev/sda1，/dev/sda2等，大于2T用GPT分区表）。示例如下： 1234567891011121314151617181920212223242526272829303132fdisk -l磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x8de7a46e 设备 Boot Start End Blocks Id System/dev/sdb1 2048 10485759 5241856 5 Extended/dev/sdb5 4096 2052095 1024000 83 Linux/dev/sdb6 2054144 4102143 1024000 83 Linux磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x000f3f8d 设备 Boot Start End Blocks Id System/dev/sda1 * 2048 411647 204800 83 Linux/dev/sda2 411648 8800255 4194304 82 Linux swap / Solaris/dev/sda3 8800256 41943039 16571392 83 Linux# fdisk -l /dev/sda1磁盘 /dev/sda1：209 MB, 209715200 字节，409600 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节 fdisk 如果不加-l选项，则会进入另一个模式，在该模式下，可以对磁盘进行分区操作。示例如下： 123456789101112131415161718192021222324252627fdisk /dev/sdb欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。命令(输入 m 获取帮助)：m命令操作 a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only)命令(输入 m 获取帮助)： 进入分区模式后，可以输入m获取命令列表的说明和帮助。其常用的操作命令如下： 命令 功能 m 获取命令列表和帮助 p 打印当前磁盘的分区情况 n 新建一个新的分区 w 保存分区 q 表示退出，若未进行保存，则会未保存退出，在此之前的一切分区工作都失效 d 删除一个分区 l 已知的分区类型列表 在工作中，常使用的就是给一个盘分一个主分区。 2.2. parted2.2.1. 使用方法parted命令是由GNU组织开发的一款功能强大的磁盘分区和分区大小调整工具，与fidisk不通，它支持调整分区的大小。作为一种设计用于Linux的工具，它没有构建成处理与fdisk关联的多种分区类型，但是，它可以处理最常见的分区格式，包括：ext2、ext3、XFS、fat16、fat32、NTFS、ReiserFS、JFS、UFS、HFS以及Linux交换分区。 语法：parted [选项] [参数] 常用选项如下： 选项 意义 -h –help，显示帮助信息 -l –list，列出所有设备的分区信息 -i –interactive，交互式模式 -s –script，脚本模式，不提示用户 -v –version，显示版本号 参数说明如下： 磁盘设备 ：指定要分区的硬盘所对应的设备文件 操作命令 ：要执行的parted命令 操作命令如下： 操作命令 意义 cp [FROM-DEVICE] FROM-MINOR TO-MINOR 将文件系统复制到另一个分区 help [COMMAND] 打印通用求助信息，或关于COMMAND的信息 mklabel 标签类型 创建新的磁盘标签（分区表） mkfs MINOR 文件系统类型 在 MINOR 创建类型为“文件系统类型”的文件系统 mkpart 分区类型 [文件系统类型] 起始点 终止点 创建一个分区 mkpartfs 分区类型 文件系统类型 起始点 终止点 创建一个带有文件系统的分区 move MINOR 起始点 终止点 移动编号为 MINOR 的分区 name MINOR 名称 将编号为 MINOR 的分区命名为“名称” print [free或MINOR或all] 打印分区表，或者分区 quit 退出程序 rescue 起始点 终止点 挽救临近“起始点”、“终止点”的遗失的分区 resize MINOR 起始点 终止点 改变位于编号为 MINOR 的分区中文件系统的大小 rm MINOR 删除编号为 MINOR 的分区 select 设备 选择要编辑的设备 set MINOR 标志 状态 改变编号为 MINOR 的分区的标志（对于PC常用的msdoc分区表来说，分区标记FLAG可有如下值：boot(引导)、hidden(隐藏)、raid(软RAID磁盘阵)、lvm(逻辑卷)、lba(LBA,Logic Block Addressing模式)）。状态的取值是: on或off 2.2.2. 操作实例1、选择分区硬盘 首先类似fdisk一样，先选择要分区的硬盘，此处为/dev/hdd。（(parted)表示在parted中输入的命令，其它为自动打印的信息）：1234[root@10.10.90.97 ~]# parted /dev/hddGNU Parted 1.8.1Using /dev/hddWelcome to GNU Parted! Type 'help' to view a list of commands. 2、创建分区 选择了/dev/hdd作为我们操作的磁盘，接下来需要创建一个分区表（在parted中可以使用help命令打印帮助信息）：12(parted) mklabelNew disk label type? gpt (我们要正确分区大于2TB的磁盘，应该使用gpt方式的分区表，输入gpt后回车) 3、完成分区操作 创建好分区表以后，接下来就可以进行分区操作了，执行mkpart命令，分别输入分区名称、文件系统和分区的起止位置：12345(parted) mkpartPartition name? []? dp1File system type? [ext2]? ext3Start? 0 （可以用百分比表示，比如Start? 0% , End? 50%）End? 500GB 4、验证分区信息 分好区后可以使用print命令打印分区信息，下面是一个print的样例：1234567(parted) printModel: VBOX HARDDISK (ide)Disk /dev/hdd: 2199GBSector size (logical/physical): 512B/512BPartition Table: gptNumber Start End Size File system Name Flags1 17.4kB 500GB 500GB dp1 5、删除分区示例 如果分区错了，可以使用rm命令删除分区，比如我们要删除上面的分区，然后打印删除后的结果：1234567(parted)rm 1 #rm后面使用分区的号码，就是用print打印出来的Number(parted) printModel: VBOX HARDDISK (ide)Disk /dev/hdd: 2199GBSector size (logical/physical): 512B/512BPartition Table: gptNumber Start End Size File system Name Flags 6、完整示例 按照上面的方法把整个硬盘都分好区，下面是一个分完后的样例：123456789101112131415161718(parted) mkpartPartition name? []? dp1File system type? [ext2]? ext3Start? 0End? 500GB(parted) mkpartPartition name? []? dp2File system type? [ext2]? ext3Start? 500GBEnd? 2199GB(parted) printModel: VBOX HARDDISK (ide)Disk /dev/hdd: 2199GBSector size (logical/physical): 512B/512BPartition Table: gptNumber Start End Size File system Name Flags1 17.4kB 500GB 500GB dp12 500GB 2199GB 1699GB dp2 7、格式化和挂载操作 完成以后我们可以使用quit命令退出parted并使用系统的mkfs命令对分区进行格式化了。123456789101112[root@10.10.90.97 ~]# fdisk -lWARNING: GPT (GUID Partition Table) detected on '/dev/hdd'! The util fdisk doesn't support GPT. Use GNU Parted.Disk /dev/hdd: 2199.0 GB, 2199022206976 bytes255 heads, 63 sectors/track, 267349 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesDevice Boot Start End Blocks Id System/dev/hdd1 1 267350 2147482623+ ee EFI GPT[root@10.10.90.97 ~]# mkfs.ext3 /dev/hdd1[root@10.10.90.97 ~]# mkfs.ext3 /dev/hdd2[root@10.10.90.97 ~]# mkdir /dp1 /dp2[root@10.10.90.97 ~]# mount /dev/hdd1 /dp1[root@10.10.90.97 ~]# mount /dev/hdd2 /dp2 3. 格式化磁盘分区磁盘分区后，还需要对其进行格式化操作才能使用。格式化就是为分区配置相应的文件系统。Win系统用Fat32和NTFS文件系统，而Linux用ext3、ext4或xfs文件系统在 CentOS 7 系统中，是以XFS作为默认的文件系统的，但是我们依旧可以给它指定ext3和ext4格式。 cat /etc/filesystems 查看系统支持哪些文件系统 3.1. mke2fs mke2fs 用于给磁盘进行格式化。它和这几个工具具有相同的功能： mkfs.ext2 mkfs.ext3 mkfs.ext4但需要注意的是，mke2fs并不支持把分区格式化为XFS系统，而只能使用mkfs.xfs。 mke2fs 的常用选项如下： 常用选项 选项说明 -b 分区时设定每个数据区块占用的空间大小。目前，每个数据块支持1024B、2048B和4096B。（设定为别的值可能会不能用） -I 设定inode的大小 -i 设定块和inode数量的比例，比如块大小为4096，则后面加上8192，格式化后inode的数量是块数量的两倍 -N 设定inode的数量。有时默认的inode数不够用，所以要自定义inode的数量 -c 在格式化前先检测一下磁盘是否有问题，加上这个选项后，运行速度会非常慢 -L 预设该分区的标签（Label） -j 建立ext3格式的分区。如果使用mkfs.ext3命令，就不用加这个选项了 -t 指定文件系统的类型，可以是ext2、ext3和ext4 -m 1 （表示百分之一对super user的保留，最小也支持0.1）格式化时，指定预留给管理员的磁盘比例，是一个百分比，只针对 mke2fs 命令 示例如下：123456789101112131415161718192021# mke2fs -t ext4 /dev/sdb5mke2fs 1.42.9 (28-Dec-2013)文件系统标签=OS type: Linux块大小=4096 (log=2)分块大小=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks64000 inodes, 256000 blocks12800 blocks (5.00%) reserved for the super user第一个数据块=0Maximum filesystem blocks=2621440008 block groups32768 blocks per group, 32768 fragments per group8000 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376Allocating group tables: 完成正在写入inode表: 完成Creating journal (4096 blocks): 完成Writing superblocks and filesystem accounting information: 完成 使用mkfs.xfs把分区格式化为XFS类型，示例如下：12345678910# mkfs.xfs /dev/sdb7meta-data=/dev/sdb7 isize=512 agcount=4, agsize=64000 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=256000, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=855, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 可以使用-L选项来指定标签。标签会在挂载磁盘的时候使用，也可以写入配置文件，这样会很可靠。示例如下：123456789101112131415161718192021# mke2fs -L TEST -t ext4 /dev/sdb5mke2fs 1.42.9 (28-Dec-2013)文件系统标签=TESTOS type: Linux块大小=4096 (log=2)分块大小=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks64000 inodes, 256000 blocks12800 blocks (5.00%) reserved for the super user第一个数据块=0Maximum filesystem blocks=2621440008 block groups32768 blocks per group, 32768 fragments per group8000 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376Allocating group tables: 完成正在写入inode表: 完成Creating journal (4096 blocks): 完成Writing superblocks and filesystem accounting information: 完成 3.2. e2label e2label 用于查看或修改分区的标签，它只支持ext格式的文件系统，而不支持XFS文件系统。 示例如下：12345# e2label /dev/sdb5TEST# e2label /dev/sdb5 TEST1# e2label /dev/sdb5TEST1 4. 挂载和卸载磁盘分区格式化完成后，如果想要使用这些分区，就需要对它们进行挂载操作。格式化后的磁盘其实是一个块文件，类型为b。 在挂载某个分区之前，需要先建立一个挂载点，这个挂载点是以目录的形式出现的。一旦把某个分区挂载到这个挂载点（目录）下，要再往这个目录写数据时，就都会写到该分区。所以，在挂载该分区前，挂载点（目录）最好是个空目录。其实目录不为空并不影响所挂载分区的使用，但一旦挂载上了，该目录下以前的东西就看不到了（数据并没有丢失），除非卸载该分区。 4.1. /etc/fstab 配置文件这个文件的内容就是系统启动时需要挂载的各个分区。我们可以在该文件里增加系统启动时需自动挂载的分区。文件内容如下所示：12345678910111213# cat /etc/fstab## /etc/fstab# Created by anaconda on Tue Aug 15 00:19:30 2017## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=1d54c61a-2320-4f2d-92d3-0bfbcebbf797 / xfs defaults 0 0UUID=9f03989b-dc6d-4d48-99e1-a85984422d6c /boot xfs defaults 0 0UUID=4ad00c9e-66f1-42c4-99b3-d9cd326b586a swap swap defaults 0 0LABEL=TEST123 /newdir ext4 defaul 配置文件中各列的意义如下： 列数 意义 1 分区的标识，可以是分区的Label，分区的UUID，以及分区名（如/dev/sda1） 2 挂载点 3 分区的文件系统类型 4 mount的一些挂载参数。一般情况下，直接写defaults即可 5 是否被dump备份。1表示备份，0表示不备份 6 开机时是否自检磁盘。1和2都表示检测，0表示不检测。自检是，1比2优先级高，所以先检测1，再检测2。如果有多个分区需要开机检测，就都设置成2，1检测玩后会同时检测2.在CentOS7里，所有分区的该值都设置为0 下面是配置文件中第4列的常用选项： 选项 意义 default 表示按照大多数永久文件系统的默认值设置挂载定义，它包含了：rw、suid、dev、exec、auto、nouser和async async和sync async表示磁盘和内存不同步。系统每隔一段时间就会把内存数据写入磁盘中，而sync则会时时同步内存和磁盘中的数据 auto和noauto 表示开机自动挂载或是不自动挂载 ro 按只读权限挂载 rw 按可读可写权限挂载 exec和noexec 表示允许或不允许可执行文件执行，但千万不要把根分区挂载为noexec，否则将无法只用系统，甚至连mount命令都无法使用 user和nouser 表示允许或不允许root外的其他用户挂载分区。为了安全，请用nouser suid和nosuid 表示允许或不允许分区有suid属性，一般设置为nosuid usrquota 表示启动用户的磁盘配额模式。磁盘配额会针对用户限定他们使用的磁盘额度 grquota 表示启动群组的磁盘配额模式 4.2. mount mount 用于挂载分区。 直接运行 mount，会显示一大推信息，可在其中查看当前系统已挂载的所有分区、分区文件系统的类型、挂载点及一些选项等信息。如果想知道某个已挂载分区的文件系统类型，直接用mount命令查看即可。（查看未挂载的分区，可以使用后面所讲的blkid命令） 挂载操作，可以用分区名（如/dev/sdb5）、也可以用分区的Label和UUID的方式进行（更可靠）。示例如下所示：123# mount /dev/sdb5 /newdir或# mount LABEL=TEST /newdir mount的常用选项如下： 常用选项 选项说明 -a 会把 /etc/fstab 配置文件中出现的所有磁盘分区挂载上 -t 用来指定挂载的分区类型，默认不指定，会自动识别 -o 用来指定挂载的分区有哪些特性，即上面/etc/fstab配置文件中第4列的哪些（该选项常用）。例如mount -oremount,ro /dev/sdb5 /db5 重新挂载该分区为只读。mount -o loop \\*.iso 挂载点 挂载一个镜像文件 –bind 源目录 目标目录 挂载一个目录到另一个目录 建议：在进行分区的挂载操作时，最好用分区的LABEL或UUID挂载。 4.3. blkid blkid 用来获取全部磁盘分区的UUID。如果分区在格式化时指定了Label，该命令也会显示LABEL值、文件系统的类型。 示例如下：12345678# blkid/dev/sdb5: LABEL=\"TEST1\" UUID=\"d2c3e579-dc31-4121-95b8-789e41fbdd96\" TYPE=\"ext4\"/dev/sdb6: UUID=\"e9d355cd-d339-4bfe-ab4e-b6ed0a766964\" TYPE=\"xfs\"/dev/sdb7: UUID=\"ea87ed23-218c-4fed-a600-823c24ac35b2\" TYPE=\"xfs\"/dev/sda1: UUID=\"9f03989b-dc6d-4d48-99e1-a85984422d6c\" TYPE=\"xfs\"/dev/sda2: UUID=\"4ad00c9e-66f1-42c4-99b3-d9cd326b586a\" TYPE=\"swap\"/dev/sda3: UUID=\"1d54c61a-2320-4f2d-92d3-0bfbcebbf797\" TYPE=\"xfs\"/dev/sr0: UUID=\"2016-12-05-13-52-39-00\" LABEL=\"CentOS 7 x86_64\" TYPE=\"iso9660\" PTTYPE=\"dos\" 这个命令后面也可以指定查询哪个分区：12# blkid /dev/sdb5/dev/sdb5: LABEL=\"TEST1\" UUID=\"d2c3e579-dc31-4121-95b8-789e41fbdd96\" TYPE=\"ext4\" 查询到某个分区的UUID后，如何使用？用法如下：mount UUID=&quot;d2c3e579-dc31-4121-95b8-789e41fbdd96&quot; /newdir 4.4. umount umount 用于卸载分区。 格式 umount 挂载点/分区名 。注意，卸载时不能跟LABEL和UUID。 有时，umount的-l选项很有用。当当前目录在即将要卸载的分区内时，会遇到不能卸载的情况。解决这个问题的方法有两个，一个是从该分区切换到别的分区，另一个就是加上-l这个选项。 4.5. 让某个分区在开机后自动挂载有两个方法： 在/etc/fstab文件中配置 在/etc/rc.d/rc.local文件中，添加一行挂载该分区的命令（注意，命令用绝对路径的写法，且把该文件的权限设置一下： chmod a+x /etc/rc.d/rc.local。因为CentOS7中该文件默认没有执行权限） 一个小建议，那就是挂载磁盘分区的时候，尽量使用 UUID 或者 LABEL 这两种方法。 5. 建立一个Swap文件增加虚拟内存首先介绍一下dd命令。 5.1. dd dd命令用于创建指定大小的文件。 格式 dd if=指定源 of=指定目标文件 bs=指定块大小 count=指定块数量 说明： 用if指定源（一般是用/dev/zero，它是Unix系统特有的一个文件，它可以源源不断地提供”0”） 用of指定目标文件，这里写上新建文件的名字 bs乘以count的得数就是即将创建的文件的大小 5.2. 增加虚拟内存的实现方法增加虚拟磁盘的思路是：建立swapfile–&gt;格式化为swap格式–&gt;启用该虚拟磁盘。 具体操作如下： 建立swapfile ： dd if=/dev/zero of=/tmp/newdisk bs=1M count=1024 将其格式化为swap格式： mkswap -f /tmp/newdisk 挂载使用： swapon /tmp/newdisk 关闭临时swap： swapoff /tmp/newdisk 6. 补充的内容6.2. LVM 好处是扩展性好 坏处是数据损坏时可恢复性很小，因此LVM在企业中用的很少，初学时可以不学了 6.3. fsck fsck 用于修复磁盘，但有时会把磁盘中的数据弄丢，因此不常用。 格式 fsck -y 分区名 OK","tags":[]},{"title":"Linux用户与用户组管理技术","date":"2017-08-31T00:38:19.000Z","path":"2017/08/31/Linux/007. Linux用户与用户组管理技术/","text":"GO 这部分知识在日常工作中用的并不多，但是这些都是属于基础知识，也必须要掌握。 1. 认识 /etc/passwd 和 /etc/shadow这两个文件是Linux系统中最重要的文件之一。注意，Linux系统关于像这两个与用户和组有关的文件，都会在相应的目录下面自动备份成相应的名字后面加-，如：passwd- - /etc/passwd 解说每个用户都有自己的一行配置。查看该文件的内容：1234567891011# cat /etc/passwd | headroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin 由内容可知，/etc/passwd 由”:”分割成7个字段，每个字段的具体含义如下： 字段 含义 1 用户名 2 账号的口令标识 3 用户标识号，UID（0-4294967294=2^32-2） 4 组标识号，GID 5 注释说明 6 家目录 7 可用shell 说明： 用户名可以是大小写字母、数字、减号（不能出现在首位）、点或下划线，其它字符不合法。虽然用户名中可以出现点，但不建议使用，尤其是首位。另外，减号也不建议使用，容易造成混淆。 口令标识在该文件里是一个x。早期的Unix系统口令确实存放在这里，但基于安全因素，后来就将其存放在 /etc/shadow 中了，这里只用了一个x代替。 系统是通过UID来识别用户身份的。root的UID为0，如果我们创建一个用户user，并把其UID设置为0，则user和root会被系统视为同一个用户。UID的取值范围是0~65535（但实际上已经可以支持到4294967294）。CentOS 7 的普通用户标识号从1000开始。 组标识号的这个字段对应着 /etc/group 中的一条记录，其是 /etc/group 和 /etc/passwd 基本类似。 注释说明没有实际意义，只是用来备注一些关于该用户的信息，例如电话、地址等。 家目录的字段，就是说当用户登陆系统后所处的就是他自己的家目录。可以修改该字段，来自定义家目录。 允许用户登陆的shell就是在此字段来设置的。例如，/sbin/nologin 表示不允许用户登陆。这个字段的默认值是 /bin/bash - /etc/shadow 解说查看该文件的内容：1234567891011# cat /etc/shadow | headroot:$6$SlsvE2F09ZCOaE2x$I71HiFKIJ1V349nJus7X8qYfryfXz9hWPcnkEHK1g88X9aXANQV2WjPXatvPcXWH4qTmcfh19.YrSEUJjWhw8/::0:99999:7:::bin:*:17110:0:99999:7:::daemon:*:17110:0:99999:7:::adm:*:17110:0:99999:7:::lp:*:17110:0:99999:7:::sync:*:17110:0:99999:7:::shutdown:*:17110:0:99999:7:::halt:*:17110:0:99999:7:::mail:*:17110:0:99999:7:::operator:*:17110:0:99999:7::: 由内容可知，/etc/shadow 由”:”分割成9个字段，每个字段的具体含义如下： 字段 含义 1 用户名，与/etc/passwd对应 2 用户的真正的密码。这个密码已经加密。 3 上次更改密码的时间戳。这个数字以1970.1.1和上次更改密码的日期为基准计算而来。 4 表示要过多少天才可以更改密码，默认0，表示不受限制 5 表示密码多少天后到期，即在多少天内必须更改密码。例如，这里设置成30，则30天内必须要更改一次密码；否则，将不能登陆系统。默认99999，可以理解为永远不需要改 6 表示密码到期前的警告期限。若这个值设置为7，则表示当7天后密码过期时，系统就发出警告，提醒用户他的密码将在7天后过期 7 表示账号的失效期限。如果这个值设置为3，则表示密码已经到期，然而用户并没有在密码到期前修改密码，那么再过3天，这个账号便失效，即锁定 8 表示该账号的生命周期。和第3个字段一样，这个周期是按距离1970.1.1多少天换算的。它的含义是，账号在这个日期前可以使用，到期后账号将作废。 9 作为保留用的，没有什么意义 说明： 密码，默认用SHA-512加密过的，且不可逆解密 $1 : MD5加密 $5 : SHA-256加密 $6 : SHA-512加密 !! : 表示用户未设置密码 : 表示用户被锁定 2. 用户和用户组管理下面的命令是用来创建、删除用户和组的，以及更改其属性的。 - groupadd groupadd 用来创建用户组 格式 groupadd [-g GID] groupname 相关的配置文件为 /etc/group 和 /etc/gshadow 示例如下：123# groupadd greptest1# tail -1 /etc/groupgreptest1:x:1008: 如果不加-g选项，则按照系统默认的GID创建组。跟UID一样，GID也是从1000开始的。我们也可以按如下操作自定义GID：1234# groupadd -g 1010 grouptest2# tail -2 /etc/groupgreptest1:x:1008:grouptest2:x:1010: - groupdel groupdel 用来删除用户组 格式 groupdel groupname 示例如下：1234# groupdel grouptest2# tail -2 /etc/groupmysql:x:1007:greptest1:x:1008: 命令groupdel没有特殊选项，但有一种情况不能删除组，如下所示：12# groupdel user1groupdel：不能移除用户“user1”的主组 上例中，user1组中包含user1用户，只有在该组中移除了user1用户后才可以删除该组。 - useradd useradd 用来添加用户。 格式 useradd [-u UID] [-g GID] [-d HOME] [-M] [-s] username 相关的配置文件为 /etc/passwd 和 /etc/shadow 选项 意义 -u 自定义UID -g 使新用户属于已经存在的某个组，后面可以跟GID，也可以跟组名 -G 该选项可跟多个组名，为用户指定多个扩展组 -d 自定义用户的家目录 -M 表示不建立家目录 -s 自定义Shell 说明： 如果useradd不加任何选项，直接跟用户名，则会创建一个跟用户名相同的组。 如果 -g 选项后面跟一个不存在的GID，则会报错，提示该组不存在。 加上 -M 选项后，则不建立用户家目录，但在/etc/passwd文件中仍然有这个字段，所以它的作用只是不创建那个目录。但是我们可以在之后为其创建家目录，并将其属主和属组的属性改为该用户：chmod -R user:user /home/user/；创建家目录后，还需要把相关的默认配置文件拷贝过去： cp -v /etc/skel/.b* /home/username 即可） - userdel userdel 用于删除用户。 格式 userdel [-r] username 说明： 选项-r的作用是，当删除用户时，一并删除该用户的家目录和邮件目录。 - usermod usermod 用于修改用户的属性 格式 usermod 选项 用户名 常用选项 含义 -s Shell类型 修改用户的Shell类型 -d 家目录绝对路径 修改用户家目录（只修改配置文件，并没有为其创建新的家目录） -u UID 修改用户的UID -g GID 为用户修改主组 -G 附加组名 为用户添加附加组 -L 锁定用户的账号 -U 解锁用户 - id id 用户名 用来查看用户的UID和GID - chfn chfn 用于修改用户的finger，即/etc/passwd文件中第五个字段所显示的信息。这个命令在工作中几乎用不到。 格式 chfn username 3. 用户密码管理密码对于一个用户来说是非常的关键，而密码管理也是系统管理员的一项非常重要的任务。 - 密码设置的规则创建用户后，默认是没有设置密码的，只有设置好密码后，才可以登陆系统。为了安全，在为用户创建密码时，应该遵循一些密码设置的规则，这些规则是为了密码的安全性而考虑的。 长度大于10个字符 密码中包含大小写字母、数字以及特殊字符等 不规则性（即不要出现常用的单词、类似于123456这样的密码等） 密码中不要带有名字、电话、生日等信息 - passwd passwd 用于设置密码。 格式 passwd [username] 说明： passwd后面不加用户名，则为自己设置密码 passwd后面加上用户名，则为该用户设置密码（以root身份） 注意：只有root才可以修改其他用户的密码，普通用户只能修改自己的密码 passwd --stdin username 即可实现只输入一次密码就更改成功的效果（这在脚本中经常使用） echo &quot;密码字符串&quot; | passwd --stdin username 即可实现将用户的密码直接设置为密码字符串 echo -e &quot;密码字符串第一遍\\n密码字符串第二遍\\n&quot; | passwd username 也可实现上面的功能 - mkpasswd mkpasswd 用于生成密码。 若是Linux没有这个命令，则需要安装一下expect： yum install -y expect。 常用选项 选项说明 -l 数字 指定生成密码的长度 -s 数字 指定特殊字符的个数 -d 数字 指定数字的个数 4. 用户身份切换- 查看当前用户 who am i 用于查看当前登陆的用户身份、登陆终端、登陆时间和来源IP whoami 用于查看当前登陆的用户的名字 w 用于查看当前登陆系统的用户的详细信息 - su su 用于切换用户身份。 格式 su [-] [username] 说明： su 的后面可以跟-，也可以不跟。加上-，即表示完整切换用户身份，即环境变量也切换过来 普通用户的su命令不加username，表示切换到root身份，需要输入root的密码才能成功切换 root用此命令切换身份时，不需要输入该用户的密码 su -c &quot;命令&quot; 用户名 用该用户的身份执行命令（这在以后写脚本的时候会用到） - sudo sudo 用于使用root身份执行一条命令。 用su可以切换用户身份，而且每个普通用户都能切换到root身份。如果某个用户不小心泄露了root的密码，那岂不是系统非常不安全？为了改进这个问题，Linux系统工程师设计了sudo这个命令。 使用sudo命令执行一个只有root才能执行的命令是可以办到的，但是需要输入密码。这个密码并不是root的密码，而是用户自己的密码。默认情况下，只有root用户能使用sudo命令，普通用户想要使用sudo，是需要root预先设定的。 可以使用visudo命令编辑相关的配置文件/etc/sudoers。如果没有visudo这个命令，则需安装yum install -y sudo 默认root支持sudo，是因为在配置文件/etc/sudoers中有一行 root ALL=(ALL) ALL。在改行下面添加一行 test ALL=(ALL) ALL，就可以让test用户拥有使用sudo的特权。这行配置的含义如下： 段数 含义 第一段 用户名，指定让哪个用户有sudo特权 第二段 ALL=（ALL），左边的ALL指的是所有的主机，右边的ALL指的是获取哪个用户的身份。第二段几乎都不用配置 第三段 设定可以使用sudo执行的命令有哪些 一个例子：1aming ALL=(root) NOPASSWD: /bin/ls, /bin/su 上面例子的意思是：不允许aming用户修改root的密码，且切换root用户时不需要输入root密码） 如果每增加一个用户就设置一行，这样太麻烦了，所以可以这样设置：把#wheel ALL=(ALL) ALL前面的#去掉，让这一行生效。它的意思是，wheel这个组的所有用户都拥有了使用sudo的权利。接下来，只要把需要设置sudo权限的用户加入到wheel这个组中即可。 - 关于sudo命令的一个很实用的案例需求：只允许使用普通账户登陆，并且普通用户登陆后，可以不用输入密码就能用sudo切换到root身份。 实现方法：1234567# visudo然后在文件的最后加入如下三行：User_Alias USER_SU = test,test1,amingCmnd_Alias SU = /usr/bin/suUSER_SU ALL=(ALL) NOPASSWD:SU 说明： 第一行设置了一个user的别名，USER_SU相当于test、test1和aming三个用户。可以写多个用户 第二行设定了一个命令别名，SU相当于/usr/bin/su，可以写多个命令 第三行就是类似于 root ALL=(ALL) ALL 这条配置语句。其中NOPASSWD的意思是：普通用户使用sudo时，不需要输入自己的密码 注意：这种配置方法有一个问题，就是普通用户可以使用su -命令切换到root账户，然后他可以再修改root的密码就能直接登陆root了。还有一个更好的办法，那就是下面的”不允许root远程登陆Linux” - 不允许root远程登陆Linux/etc/ssh/sshd_config 为sshd服务的配置文件，默认允许root用户通过ssh远程登陆Linux。要想不允许root用户远程登陆Linux，具体的操作方法为： 修改配置文件/etc/ssh/sshd_config 在配置文件中查找 #PermitRootLogin yes 并把它修改为 PermitRootLogin no 保存配置文件后，需要重启sshd服务：systemctl restart sshd.service 注意：这个方法只适用于通过ssh远程登陆Linux的情况。 补充一个小知识：/etc/ssh/sshd_config（ 为 sshd 服务的配置文件）中，将#UseDNS yes 改成 UseDNS no ，即可实现在远程登陆时的等待问题。 OK","tags":[]},{"title":"Linux文件与目录管理技术","date":"2017-08-26T14:49:24.000Z","path":"2017/08/26/Linux/006. Linux文件与目录管理技术/","text":"GO 0. 几个基本概念- 绝对路径和相对路径 绝对路径：由根目录写起的路径。如：/usr/local/mysql。 相对路径：不是由根目录。写起的路径。如：../ 表示上一层路径，./ 表示本层路径。 1. 文件管理命令- ls ls （list）用于查看某个目录下有何文件。 常用选项 选项说明 无参数 列出目录下的文件和目录，不包含隐藏文件 -a 列出所有文件，包括隐藏文件，./ 和 ../ -l 列出详细信息（文件类型+文件所有者权限+属组权限+其它权限+inode数量+属主+属组+文件大小+mtime+文件名） -d 针对目录的，只列出目录本身；如果不加-d，那么会列出目录下面的文件来 -h 自动以合适的方式显示文件的大小 -t 按时间的顺序排列文件（新的在上面） -i 可查看文件的inode -F 在文件末尾显示文件类型 - pwd pwd （print working directory）用于查看当前所在路径。 常用选项 选项说明 -L（不加也可） 显示逻辑上的路径（默认） -P 在查看链接文件时显示真正的路径，即不是链接文件的地址 - cd cd （change directory，是shell的内置命令）用于更改文件路径。 常用参数 参数说明 无参数 直接到当前用户的家目录下 ~username 进入username用户的家目录下 - 切换到上一次所在的目录 绝对或相对路径 到指定的目录下 注意：cd 后面只能跟目录，如何跟文件会报错。 - mkdir mkdir （make directory）用于创建目录。 格式为 mkdir [-mp] [目录名称] 常用选项 选项说明 -m 指定要创建目录的权限（不常用） -p 可一次性创建多层的空的目录，否则一次只能创建一层目录。后面跟一个已存在的目录名时，它不会做任何事情，只是不报错而已 -v 可视化创建过程 说明： 若是所创建的目录和已存在的文件名字一样的话，会创建失败 可同时创建多个目录，只需在后面用空格隔开目录名即可 - rmdir rmdir （remove directory）用于删除空的目录，后面可以是一个目录，也可以是多个目录（用空格隔开）。 常用选项 选项说明 -p 连续删除一连串空的目录 -v 可视化删除过程 注意：只能用来删除空的目录，否则会报错，即不能用来删除非空目录和删除文件。 - rm rm （remove）用于删除文件或目录。 常用选项 选项说明 -r 删除目录时要加的选项 -i 交互式的进行删除工作，即问你是不是确定要删除（默认带着呢） -f 强制安静删除，不用输入y或n来确认，且不再屏幕上显示任何信息，不论什么情况（比如目标文件不存在） 在写脚本时，我们会用绝对路径的形式/bin/rm，这是个危险的命令，需要谨慎操作！ - cp cp （copy）用于复制文件或目录。 格式为 cp [选项] [来源文件] [目的文件] 常用选项 选项说明 -r 复制目录时要加的选项 -i 安全选项，交互式进行工作，若是遇到一个已存在的文件，会询问是否覆盖（默认带着呢） -p 可把文件的权限页复制过去 - mv mv （move）用于移动或重命名文件或目录。 格式为 mv [选项] [源文件或目录] [目标文件或目录] 情况 结果 目标文件是目录，但该目录不存在 重命名该目录 目标文件是目录，且该目录存在 移动该目录 目标文件是文件，但该文件不存在 重命名该文件 目标文件是文件，且该文件存在 会询问是否覆盖 常用选项 选项说明 -i 交互式的进行工作，即问你是不是确定要删除（默认带着呢） -v 可视化过程 - touch格式 touch filename 若文件存在，更改文件的三个time属性 若文件不存在，则会新建这个文件 2. 文件内容查看命令- cat cat 用于查看一个文件的内容并将其显示在屏幕上。 常用选项 选项说明 -n 显示出行号 -A 显示所有的内容，包含特殊字符 示例：123456789101112131415161718# cat test.txt11111111111222222222223333333333355555555555# cat -n test.txt1 111111111112 222222222223 3333333333345 55555555555# cat -A test.txt11111111111$22222222222$33333333333$$55555555555$ - tac tac 是 cat 倒着写的，因此功能是把文件内容倒叙的方式显示在屏幕上。选项与cat相同。 - more more 用于查看一个文件的内容。当文件内容太多而一屏不能全部显示时，会分页显示，由按键操作： 按键 说明 空格 向下一页（看完所有内容后会退出） Ctrl+F 同空格 Ctrl+D 向上翻页 q 提前退出阅读 - less less 作用与more相同，只是功能要多一些，是增强版的more。 按键 说明 空格 一屏一屏向下翻页 j 向下移动一行 k 向上移动一行 g 到第一行行首去 G 到最后一行行首去 Ctrl+B 向上翻 Ctrl+F 向下翻 PGUP 向上翻页 PGDN 向下翻页 q 退出 less和more都支持用 / （向下查找）或 ? （向上查找）来进行字符串的查找，并且按 n 查找下一个，按 N 反向查找下一个。 - head head 用于显示文件的前几行。（默认不加选项，会显示最先十行） 常用选项 选项说明 -n 数字 显示指定的前几行 -n数字 同上 -数字 同上 - tail tail 和head类似，用于显示文件的最后几行内容。（默认不加选项，会显示最后十行） 常用选项 选项说明 -n 数字 显示指定的最后几行 -n数字 同上 -数字 同上 -f 如果文件内容不断地在增加，那么加上该选项就可以动态、实时地查看文件的内容。例如用的最多的：查看日志tail -f /var/log/messages 3. Linux文件属性- 文件属性的意义用命令 ls -l 查看当前目录下的文件时，共显示了9列内容（用空格分列），它们都代表着什么意思呢？如下表所示：12# ls -l test.txt-rw-r--r-- 1 root root 49 8月 27 17:45 test.txt 列数 意义 1 包含该文件的类型、所有者所属组以及其他用户对该文件的权限 2 表示该文件所占用的节点（inode），如果是目录，则该数值与该目录下的子目录数量有关 3 该文件的所有者 4 该文件的所属主 5 该文件的大小 678 表示该文件最后一次被修改的时间（mtime），一次为月份、日期、时间 9 文件名 - Linux下文件的类型在文件属性的第一列的第一个字符上我们可以看出该文件属于什么类型，主要有以下几种 字符 所代表的文件类型 - 普通文件 d 目录文件 l 链接文件 b 块设备文件，比如/dev/sda就是这样的文件 c 串行端口设备文件（又称字符设备文件），比如键盘、鼠标、打印机、tty终端等都是这样的文件 s 套接字文件（socket），用于进程间的通信 p 管道文件（与管道命令相关） - Linux文件的权限文件类型后面的9位为权限，每三个为一组，分别是文件的所有者（user）、所属组（group）和其他人（others）对该文件的权限。r 为可读权限，w 为可写权限，x 为可执行权限，- 为没有权限。另外，有的文件在最后还会有一个符号，一个点”.”或者是一个加号”+”。在CentOS 5的老版本中是没有这个的，这是因为新版本中的ls添加了SELinux或者ACL属性。如果文件或目录使用了SELinux context属性，这里会是一个点”.”；如果设置了ACL属性，这里会是一个加号”+”。（这个概念先了解即可） - 文件的三种权限对文件的作用对于文件来说，它的意义如下： 权限 意义 r Read 可读取此文件的实际内容，如读取文本文件的文字内容等 w Write 可以编辑、新增或者是修改该文件的内容（但不含删除该文件） x eXecute 该文件具有可以被系统执行的权限 - 文件的三种权限对目录的作用对于目录来说，它的意义如下： 权限 意义 r read contents in directory 具有读取目录结构列表的权限 w modify contents of directory 具有更改目录结构列表的权限，如新建文件与目录，删除已存在的文件或目录（不论它们是什么权限），将已存在的文件或目录重命名，转移该目录内的文件和目录 x access directory 决定用户能否进入该目录成为工作目录 - 文件的三种时间属性 时间属性 意义 atime access time 是在读取文件或执行文件时更改的 mtime modified time 是在写入文件时随文件内容的更改而更改的 ctime change time 是在写入文件、更改所有者、权限或链接设置时随inode内容的更改而更改的 - stat stat 用于查看文件的三个时间属性。 格式 stat filename - touch格式 touch 已存在的文件名 用于更改文件的三个时间属性为当前时间 - inode中包含的元信息具体说来有一下内容： 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个： ctime mtime atime 链接数：即有多少文件名指向这个inode 文件数据block的位置 4. 更改文件的权限- chgrp chgrp 用于更改文件的所属组。（chown可以代替它） 格式为 chgrp [组名] [文件名] 常用选项 选项说明 -R 作用于目录，连同目录下的所有文件和子目录全部都更改 - chown chown 用于更改文件的所有者，也可以更改所属组。 格式为 chown [-R] 账户名 文件名 或 chown [-R] 账户名:组名 文件名 常用选项 选项说明 -R 作用于目录，递归（继承）更改，即连同目录下的所有文件和子目录全部都更改 - chmod chmod 用于更改文件的权限。 格式为 chmod [-R] xyz 文件名 （其中xyz代表的数字） Linux中也可用数字代表rwx的权限，具体规则为：r为4，w为2，x为1，-为0。u为所有者，g为所属组，o为其他人，a为全部人。+为增加权限，-为去除权限，=为设置权限。权限的设置就是上面各个符号的组合。 常用选项 选项说明 -R 作用于目录，递归更改权限，即连同目录下的所有文件和子目录全部都更改 -v 可视化工作过程 几个例子如下：1234567chmod u=rwx,go=rw test.txtchmod ugo=rw test.txtchmod a=rw test.txtchmod a+x test.txtchmod a-x test.txtchmod 700 test.txtchmod 655 test.txt - umask默认情况下，新建一个目录的权限值为755，新建一个普通文件的权限值为644，那么这个值是由谁来控制的呢？那就是 umask 了。 umask 用于改变文件的默认权限 格式为 umask xxx （xxx在这里代表权限的三个数字） 几个例子如下：12umask # 查看umask的预设值umask 0022 # 设置umask的值 - umask的作用原理先了解以下两条规则： 若用户建立普通文件，则预设没有可执行权限，只有r、w两个权限，最大值为666（-rw-rw-rw-） 若用户建立目录，则预设所有权限均开放，即777（drwxrwxrwx） umask值的作用原理便是在这两条规则上，设置上需要减去的规则数字。 需要注意的是，root的umask值通常为022，而一般用户通常为002。umask的值可以在/etc/bashrc里面更改。 - chattr chattr 用于修改文件的特殊权限 格式为 chattr [+-=] [Asaci] [文件或者目录名]（其中+、-、=分别表示增加、减少和设定）。各个选项的意义如下： 常用选项 选项说明 A 文件或目录的atime将不可修改 s 会将数据同步写入磁盘中 a 只能追加不能删除，非root用户不能设定该属性 c 自动压缩该文件，读取时自动解压 i 锁定文件，不能删除、重命名、设定链接文件、写入以及新增数据 上表中最最常用的两个选项就是 a 和 i。 - lsattr lsattr 用于读取文件或目录的特殊权限 格式为 lsattr [-adR] 文件或目录名 常用选项 选项说明 -a 类似于ls的-a选项，即连同隐藏文件一同列出 -d 查看目录本身的特殊权限，而不是目录下文件的特殊权限 -R 连同子目录的数据一同列出 - Set UID、Set GID和Sticky Bit前面介绍权限的时候其实一共是4位，我们一直都是用3位数，其实最前面还有一位，那就是代表SUID、SGID和SBIT这三个属性的。它们的意义如下： SUID：该权限针对二进制可执行文件，使文件在执行阶段具有文件所有者的权限。比如，passwd这个命令就具有该权限。当普通用户执行passwd命令时，可以临时获得root权限，从而可以更改密码。 SGID：该权限可以作用在文件上（二进制可执行文件），也可以作用在目录上。当作用在文件上时，其功能和 Set UID 类似，它会使文件在执行阶段具有文件所属组的权限。目录被设置这个权限后，任何用户在此目录下创建的文件都具有和该目录所属的组相同的组。 SBIT：该权限只能作用于目录上。可以理解为防删除位。文件是否可以被某用户删除，主要取决于该文件所在的目录是否对该用户具有写权限。如果没有写权限，则这个目录下的所有问价都不能删除，同时也不能添加新的文件。如果希望用户能够添加文件但不能删除该目录下其他用户的文件，则可以对父目录增加该权限。设置该权限后，就算用户对该目录具有写权限，也不能删除其他用户的文件。例如，/tmp 目录就是设置了这个权限。 设置方法如下： SUID : chmod u[+-]s filename 或 chmod [40]*** filename SGID : chmod g[+-]s filename 或 chmod [20]*** filename SBIT : chmod o[+-]t filename 或 chmod [10]*** filename 说明： 设置了以上的各个权限后，文件的相应权限位上的情况分别是： SUID：所有者的可执行权限x变为了s； SGID：所属组的可执行权限x变为了s； SBIT：其他人的可执行权限变为了t。 有时候可能会发现某个文件的相关属性位上的字母为S（大写）和T（大写），这是因为文件本身就不具备该身份的可执行权限，所以即使设置了这三个属性中的其中一种，也不会生效。 5. 文件搜索命令- which which 只能用来查找PATH环境变量中出现的路径下可执行文件。 格式：which command 说明： 在PATH变量指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。也就是说，使用which命令就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令 cd用which是查不到的，因为cd 是bash的内置命令 - whereis whereis 命令通过欲生成的一个文件列表库查找与给出的文件名相关的文件。类似于模糊查找，只要文件名中包含给定的字符串，就会列出来。这个命令很少用到 格式 whereis [-bms] [关键字] 常用选项 选项说明 -b 只查找二进制文件 -m 只查找帮助文件（在man目录下的文件） -s 只查找源代码文件 -u 没有说明文档的文件 说明： 也是局限在某些目录下，只在以下几个目录中搜索：/bin 、/sbin、/sur/bin 、/usr/sbin、/usr/share/man/man1/ 等等。 只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s），如果省略参数，则返回所有信息。 - locate locate 命令类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里，后面直接跟文件名。 如果Linux中没有这个命令，请安装mlocate软件包。yum install -y mlocate 安装好mlocate后，要更新相关的库：updatedb （注意：这个操作会占用大量的服务器资源） 可以在文件 /etc/updated.conf 中配置这个数据库额生成（或更新）规则。 locate 所搜索到的文件列表，不管是目录名还是文件名，只要包含该关键字，都会列出来，所以它不适合精确搜索，因此并不会被常用。 - find find 用于精确查找某些符合给定条件的文件，功能非常强大。 格式 find 指定目录 指定条件 指定动作 指定目录：所要搜索的目录及其所有子目录。默认为当前目录。 指定条件：所有搜索的文件的特征。 指定动作：对搜索结果进行特定的处理。 常用参数 参数说明 -atime +n/-n 表示访问或执行时间大于或小于n天的文件 -ctime +n/-n 表示写入、更改inode属性（如更改所有者、权限或者链接）的时间大于或小于n天的文件 -mtime +n/-n/n 表示更改内容的时间大于、小于或等于n天的文件（该参数用的最多） -mmin -n 表示在十分之之内更改内容的文件 -name filename 表示直接查找该文件名的文件（常用） -type 类型符 表示通过文件类型查找文件。filestype包含了f、b、c、d、l、s等类型 在条件前加! 表示对条件进行取反 条件1 -o 条件2 在两个条件之间，-o表示或者，不加任何东西就是并且 注意：find命令可结合管道命令和通配符来配合使用 |xargs 命令 -exec 命令 {} \\; 不交互直接进行处理 -ok 命令 {} \\; 交互式地进行处理 6. 链接文件- 硬链接硬链接是再建立一个inode链接到文件放置的区块域，即进行硬链接时该文件内容没有任何变化，只是增加了一个指向这个文件的inode，并不会额外占用磁盘空间。 硬链接有两个限制： 不能跨文件系统，因为不同的文件系统有不同的inode table 不能链接目录 - 软链接软链接相当于快捷方式。它与硬链接不同的是，软链接是建立一个独立的文件，当读取到这个链接文件时，它会把读取的行为转发到文件所链接的文件上。 - ln ln 用于创建链接文件，即硬链接和软链接 格式 ln [-s] [来源文件] [目的文件] 说明： ln的常用选项就是-s 加上-s就是创建软链接 不加-s就是创建硬链接 示例：12ln test test-hard //创建test的硬链接文件test-hardln -s test test-soft //创建test的软链接文件test-soft OK","tags":[]},{"title":"Linux系统目录结构","date":"2017-08-26T09:24:25.000Z","path":"2017/08/26/Linux/005. Linux系统目录结构/","text":"GO 1. FHS标准 根据FHS（Filesystem Hierarchy Standard ）官方文件说明，其主要目的是希望让用户可以了解到已安装软件通常放在哪个目录下，所以其希望独立的开发商、操作系统制作者以及想要维护系统的用户，都能够遵循FHS标准。 FHS将目录定义为四种交互作用的形态： 可分享的：可以分享给其它系统挂载使用的目录，所以包括可执行文件与用户的邮件等数据。 不可分享的：自己机器上米娜运行的设备文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以就不适合分享给其它主机了。 不可变动的：有些数据是不会经常变动的，跟随着distribution而不变动。例如函数、说明文件、系统管理员所管理的主机服务配置文件等。 可变动的：经常改变的数据，例如登陆文件、新闻组等。 事实上，FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已。分别是下面这三个目录的定义： / （root，根目录）：与开机系统有关。 FHS标准建议：根目录所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小，这样不但性能最好，其根目录所在文件系统也较不容易发生问题。 根目录下面应该放置这些目录： /bin /boot /dev /etc /home /lib /media /mnt /opt /root /sbin /srv /tmp 特别注意，根目录与开机有关，开机过程中仅有根目录会被挂载，其它分区则是在开机完成之后才会持续进行挂载的行为。正因如此，根目录下与开机过程有关的目录就不能够与根目录放到不同的分区去。这些目录如下： /etc ：配置文件 /bin ：重要的执行文件 /dev ：所需要的设备文件 /lib ：执行文件所需的函数库与内核所需的模块 /sbin ：重要的系统执行文件 /usr （Unix Software Resource）：与软件安装和执行有关。 这里面放置的数据属于可分享的与不可变动的。 FHS建议所有软件开发者应该将他们的数据合理地分别放置到这个目录下的子目录，而不是自行新建该软件自己独立的目录。 该目录下面有如下所示的目录： /usr/X11R6/ /usr/bin/ /usr/include/ /usr/lib/ /usr/local/ /usr/sbin/ /usr/share/ /usr/src/ /var （VARiable）：与系统运作过程有关。 该目录只要针对常态性变动的文件，包括缓存（cache）、登陆文件（log file）以及某些软件运行时所产生的文件，包括程序文件（lock file，run file），或者例如MySQL数据库的文件等。 常见的子目录如下： /var/cache/ /var/lib/ /var/lock/ /var/log/ /var/mail/ /var/run/ /var/spool/ 2. Linux系统目录说明 常见目录的作用整理如下表： 目录名 作用 /bin bin是Binary的缩写，该目录下存放的是最常用的命令 /boot 该目录下存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件 /dev dev是Device（设备）的缩写。该目录下存放的是Linux的外部设备。在Linux中，访问设备的方式和访问文件的方式是相同的 /etc 该目录下存放的是所有系统管理所需要的配置文件和子目录 /home 这是用户的家目录。在Linux中， 每个用户都有一个自己的目录，一般该目录名是以用户名来命名的（root用户有自己的家目录/root） /lib和/lib64 这两个目录下存放的是系统最基本的动态链接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库。其中/lib64为64位的软件包的库文件所在目录 /media 系统会自动识别一些设备（如U盘、光驱等），当识别后，Linux会把识别的设备挂载到该目录下 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统。我们可以将光驱挂载到/mnt/上，然后进入该目录查看光驱里的内容 /opt 这是给主机额外安装软件所设置的目录，该目录默认为空。比如，你要安装一个Oracle数据库，可以放到该目录下。 /proc 该目录是一个虚拟目录，是系统内存的映射，可以直接访问它来获取系统信息。该目录的内容在内存里，我们可以直接修改里面的某些文件。内存和CPU的详细信息都在该目录下（cpuinfo和meminfo），修改内核参数或调优时会在该目录下进行文件的参数修改，其中的数字目录文件表示进程ID，其中的文件表示状态等信息。比如，可以通过下面的命令来屏蔽主机的ping命令，使他人无法ping通你的机器。在日常工作中，你会经常用到类似的用法： echo 1 &gt; /proc/sys/net/icmp_echo_ignore_all /root 该目录是系统管理员的用户家目录 /run 这个目录其实和/var/run是同一个目录，它们属于链接文件的关系，这里面存放的是一些服务的PID。一个服务启动完后，是有一个PID文件的。 /sbin s就是Super User的意思，该目录存放的是系统管理员使用的系统管理程序 /srv 该目录存放的是一些服务启动之后需要提取的数据 /sys 该目录存放的是与硬件驱动程序相关的信息 /sys/class 包含所有注册在kernel里面的设备类型，链接到device /sys/dev 维护一个按照字符设备和块设备的主次号码列表，链接到device /sys/device 是全局设备结构体系，包含所有被发现的注册在各种总线上的各种物理设备，是内核层次表达模型，也是/sys文件系统管理设备的最重要的目录结构 /sys/fs 描述系统中所有的文件系统 /sys/kernel 存放的是内核中所有可调整的参数 /tmp 该目录用来存放一些临时文件 /usr 这是一个非常重要的目录，用户的很多应用程序和文件都存放在该目录下 /usr/bin 该目录存放的是系统用户使用的应用程序 /usr/sbin 该目录存放的是超级用户使用的比较高级的管理程序和系统守护进程 /usr/src 该目录是内核源代码默认的放置目录 /var 该目录存放的是不断扩充且经常修改的目录，包括各种日志文件或者PID文件，其中刚刚提到的/var/run就是在这个目录下面 OK","tags":[]},{"title":"CentOS的单用户和救援模式","date":"2017-08-26T08:00:47.000Z","path":"2017/08/26/Linux/004. CentOS的单用户和救援模式/","text":"GO 1. CentOS 6 1.1 CentOS 6 的七个运行级别 运行级别的配置文件为 /etc/inittab。查看这个文件，其中有七个运行级别的说明。 cat /etc/inittab 查看该文件的的内容如下： 12345678910# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault: 七个运行级别的说明 运行级别 说明 0 关机 1 单用户 2 多用户模式，但没有NFS服务 3 命令行模式 4 预留，没有用 5 图形界面模式 6 重启 默认运行级别的设置 /etc/inittab配置文件的最后一行便是用来设置默认运行级别的。 id:3:initdefault: 把其中的数字更改，就更改了默认的运行级别 默认是3级别，在命令行下，运行 init 5 就是启动图形模式了。 同理，init 0 为关机，init 6 为重启 要想启动图像，要提前安装好图形的支持，用下面的命令安装： yum groupinstall “Desktop” “X Window System” 1.2. CentOS 6 的单用户模式 单用户相当于Windows里的安全模式，假如忘记了root密码，则进入该模式即可重新修改root密码。按下面的方法进入这种模式（init 1 是进不了的）： 重启Linux，3秒内，按一下回车 若有设置grub密码，需先按p，输入密码后方可进行后面的操作 此时 CentOS (2.6.32-504.el6.x86_64) 这一行是高亮的，即我们选中的就是这一行，这行的意思是 Linux版本为 CentOS，后面小括号内是内核版本信息。 另外在这个界面里，我们还可以获取一些信息，输入 e会在启动前编辑命令行； 输入 a 会在启动前更改内核的一些参数； 输入 c 则会进入命令行。 按e，选择第二行，再按e（目的是修改启动参数） 在最后面加入single或者数字1，再或者大写字母S 先按回车再按b（boot） 这样就成功进入单用户模式，我们可以在该模式下修改root 密码。 说明：如果在Linux的启动参数中，去掉rhgb，则系统在启动过程中就没有进度条了，只显示详细的进程启动 1.3. CentOS 6 的救援模式 救援模式即 rescue，这个模式主要是应用于，系统无法进入的情况。如 grub 损坏或者某一个配置文件修改出错。救援模式相当于Windows的WinPE，是一个内存操作系统。使用方法如下： 光盘或USB启动，进入系统安装盘启动界面。 使用上下方向键选择 Rescue installed system 然后回车。语言这一项保持默认，直接回车。 键盘类型，也默认，直接回车。 接着让我们设置网络，如果不需要联网直接用 tab 键选择 no，然后回车。 接下来这一步，提示我们 Rescue 环境将会找到我们已经安装的 Linux 系统，并将其挂载到/mnt/sysimage 下，这一步我们选择 Continue 然后回车。 回车后，将会看到一个小提示框，它告诉我们 Linux 系统挂载到了/mnt/sysimage，如果想获得 root 环境，需要执行命令 chroot /mnt/sysimage。 继续回车，又弹出下面的提示。 再继续回车，此时又出现一个框，有三种模式可以选择： shell 模式会直接进入命令行，可以进行的操作有编辑文件、修改用户密码等； fakd 是诊断模式； reboot 会直接重启； 这一步我们选择第一个 shell 模式，然后回车，进入 root 环境。 此时还不能操作 Linux 系统上的文件，因为目前还在光盘上的系统上。要想修改原来 Linux 系统上的文件还需要执行一个命令： chroot /mnt/sysimage 原来的 bash-4.1 变成了 sh-4.1 , 此时我们才可以像在原来的Linux 系统上做一些操作，比如更改 root 密码或者修改某个文件等。任务完成后，需要先exit，才能关机或重启。 2. CentOS 7 2.1. CentOS 7 的emergency模式 这个模式相当与CentOS 6的单用户模式，只不过在 7 版本开始已经不用运行级别这一概念了，所以也就没有了单用户模式。不过，在emergency模式下可以达到之前的单用户模式下的操作目的。 这个模式的使用方法如下： 重启系统 重启Linux，3秒内，按一下回车 按方向键移动光标，定位在第一行，按字母e编辑它，然后进入另一个界面 移动向下的方向键，把光标定位到linux16开头的行 进入emergency模式 按向右的方向键，将光标移动到 ro 那里，把 ro 改成 rw init=/sysroot/bin/bash 同时按住Ctrl和x这两个键，系统就会进入该模式了 修改root密码 首先切换到原始系统，chroot /sysroot/ 然后再进行修改密码passwd等操作，若是出现乱码，可以设置语系为英语，LANG=en 修改密码后，需要执行下这个命令： touch /.autorelabel 这个命令一定要写对，否则更改的密码将不能生效 执行这一步的作用是让SELinux生效，如果不执行，所修改的密码不会生效 执行完上述命令后，同时按Ctrl和d键（即等同于输入exit）,再进行系统的重启（reboot）。之后就可以用新的密码登陆了 2.2. CentOS 7 的救援模式 CentOS 7 的救援模式的使用方法如下： 光盘或USB启动进入到安装界面 进入rescue模式 使用上下方向键选择 Troubleshooting 回车进入另一界面 使用上下方向键选择 Rescure a CentOS Linux system，连续敲两次回车进入下一界面 这一界面里会有很多提示。按照提示，选择第1项，所以输入数字”1”，回车后再次回车，由出现了一个界面 这一界面告诉我们：原始系统已挂载到了 /mnt/sysimage，若要进入原始系统，需要执行 chroot /mnt/sysimage 命令 执行命令后，进行救援工作。 救援工作完成后，退出原始系统（exit或Ctrl+D），然后重启系统。 OK","tags":[]},{"title":"远程连接Linux主机","date":"2017-08-26T05:38:51.000Z","path":"2017/08/26/Linux/003. 远程连接Linux主机/","text":"GO 1. 使用Putty连接远程Linux主机Putty免费开源，小巧玲珑，在WIndows和Linux上都支持。所以我选择使用这个工具来管理远程Linux主机。使用它的好处是：可以随意的复制粘贴，可以通过鼠标滚轮查看之前显示的历史信息。 Putty套件的工具有很多，它们的功能如下所示： PuTTY（SSH和telnet客户端软件） PSCP（SCP客户端，用来远程复制文件） PSFTP（SFTP客户端，使用SSH协议传输文件） PuTTYtel（一个只有telnet功能的客户端软件） Plink（Windows下的命令行接口，使用它可以在cmd下使用PuTTY） Pageant（SS和的密钥守护进程，开启后，密钥保存到内存中，连接时不再输入密钥的密码，PuTTY、PSCP、PSFTP和Plink都可以使用） PuTTYgen（生成密钥对的工具） 在本文中，只用到PuTTY和PuTTYgen两个软件。 1.1. 使用密码登陆 填写远程Linux基本信息 Host Name（or IP address）这一栏填 服务器的IP。 Port 这一栏保持22不变。 Connection type 也保持ssh不变。 Save Sessions 这里自定义一个名字，主要用来区分主机。 定义字符集 为了防止乱码，对于管理安装了中文支持的远程Linux系统来说，要在Putty这里也设置支持中文。 点一下左侧的 Window –&gt; Translation，看右侧的 Character set translation on received data，选择 UTF-8。 然后再点一下左侧的 Session，最后点右侧的 save。 远程连接Linux 点Open，初次连接是会有一个提示（第一次连接的时候），它的意思是要打开的Linux还未在本机登记，是否要信任它。点击“是”即可连接。 然后连接成功后即可登陆管理远程的Linux了。 1.2. 使用密钥登陆 SSH服务支持以一种安全认证机制，即密钥认证。所谓的密钥认证，实际上是使用一对加密字符串，一个称为公钥(publickey)， 任何人都可以看到其内容，用于加密；另一个称为私钥(privatekey)，只有拥有者才能看到，用于解密。通过公钥加密过的密文使用私钥可以轻松解密，但根据公钥来猜测私钥却十分困难。SSH 的密钥认证就是使用了这一特性。服务器和客户端都各自拥有自己的公钥和私钥。PuTTY 是可以使用这种机制登录 Linux 的。 生成密钥对 Putty生成密钥对的工具是Puttygen，打开它。右下角的 1024 改成 2048，这表示密钥长度为 2048 位，这样更安全，然后点一下 ―Generate‖按钮, 这样就开始生成密钥了，请来回动一下鼠标，这样才可以快速生成密钥对，大约几秒后就完了。 “Key comment”这里可以保持不变也可以自定义，它是对该密钥的简单介绍。“Kye passphrase”这里用来给你的密钥设置密码，这样安全一些，当然也可以留空，建议你设置一个密码。“Confirm passphrase”这里再输入一遍刚刚你设置的密码。 保存私钥 单击“Save private key”，选择一个存放路径，并定义名字，点“保存”。这个就是所谓的私钥（一个*.ppk文件），请把它保存到一个比较安全的地方，谨防丢掉或被别人看到。 复制公钥到Linux 回到刚才生成密钥的窗口，在 “Key”的下方有一段长长的字符串，这串字符串就是公钥的内容，把整个公钥字符串复制下来。然后粘贴到 Linux 的这个文件中： /root/.ssh/authorized_keys。注意这个文件的名字是固定的。下面请做如下操作： 创建/root/.ssh 目录，因为这个目录默认是不存在的。# mkdir /root/.ssh 更改这个目录的权限。# chmod 700 /root/.ssh 把公钥内容粘贴进/root/.ssh/authorized_keys 文件中。 vi /root/.ssh/authorized_keys 回车后，按一下“i”进入编辑模式，然后直接点击鼠标右键就粘贴了，粘贴后，按一下“Esc”键，然后输入“:wq”回车保存退出该文件。 关闭SeLinux SeLinux 是 CentOS 的一种安全机制，它的存在的确让 Linux 系统安全了很多，但也产生了不少的麻烦。在这，如果不关闭 seLinux，使用密钥登录会提示 “Server refused our key”, 关闭方法如下： 临时关闭：setenforce 0 永久关闭：vi /etc/selinux/config ，把该配置文件中的SELINUX=enforcing修改为“SELINUX=disabled”，保存退出后然后重启系统。 说明： /etc/selinux/config配置文件中有三种模式：enforcing（默认开启）、permissive（提醒）和disabled（关闭）。 关闭防火墙 关闭netfilter （即iptables） iptables -F 临时将iptables的规则清空（防火墙清空） /etc/init.d/iptables save （或service iptables save） 将清楚后的防火墙规则保存到 /etc/sysconfig/iptables 设置putty通过密钥登陆 打开 PuTTY 软件，点一下我们保存好的 session，然后点右侧的“Load”，在左侧靠下面点一下“SSH”前面的+然后选择“Auth”看右侧“Private key file for authentication:”下面的长条框里目前为空，点一下“Browse”, 找到我们刚刚保存好的私钥，点“打开”。此时这个长条框里就有了私钥的地址，当然你也可以自行编辑这个路径。然后再回到左侧，点一下最上面的“Session”，在右侧再点一下“Save”。 保存好 session 后，点一下右下方的“Open”。出现登录界面，你会发现和原来的登录提示内容有所不同。 现在不再输入 root 密码，而是需要输入密钥的密码，如果先前在生产密钥的时候你没有设置密码，输入 root 后会直接登录系统。 需要注意几点： /root/.ssh目录的权限为700 SELinux要关闭 /root/.ssh/authorized_keys文件名要写对 公钥的文件内容要粘贴对 2. 两台Linux互相登陆有时候需要在Linux系统上登陆到另一台Linux主机，这就需要用到以下的技能。用以实现这个目的，CentOS自带的客户端软件是 openssh-clients。 2.1. 检查openssh-clients是否安装 检查是否安装，运行下面的命令：ssh -V 若没有安装，则运行下面的命令安装：yum install -y openssh-clients 2.2. 使用密码登陆 登陆命令格式如下：ssh Username@IPaddress一个例子： ssh root@192.168.0.105 查看当前登陆的用户身份： whoami 仅显示用户名 who am i 显示用户名、登陆终端、登陆时间、登陆来源IP 2.3. 使用密钥登陆 客户端生成密钥对执行如下命令来生成密钥对：ssh-keygen “Enter file in which to save the key (/root/.ssh/id_rsa): “ 首先，可以自定义私钥的存放位置，默认路径为/root/.ssh/id_rsa。可以采用默认值，回车即可。 “Enter passphrase (empty for no passphrase): “ 然后，定义私钥的密码，可以留空，直接回车即可。也可以设置一个密码。 “Enter same passphrase again: “ 接下来，会让我们再一次输入密码，然后回车，变生成了密钥对了。 可以在相关的目录里面找到私钥（id_rsa）和公钥（id_rsa.pub） 把把公钥复制到目标Linux上面 查看公钥内容并复制 把复制的内容粘贴到 /root/.ssh/suthorized_keys（该文件的创建过程参考Putty的密钥登陆） 确认该文件的权限，chmod 600 /root/.ssh/authorized_keys 登录Linux ssh 目标Linux的IP地址 补充：非root用户的密钥登陆与root用户的配置过程类似。 3. 补充内容3.1. SSH限制来源IP即SSH的黑名单和白名单，是以下这两个文件： /etc/hosts.allow /etc/hosts.deny 3.2. 禁止普通用户登陆系统当服务器进行高负荷的管理操作时，禁止普通用户登陆系统的方法如下：12touch /etc/nologin //禁止rm -f /etc/nologin //取消禁止 OK","tags":[]},{"title":"Linux系统的启动流程","date":"2017-08-26T05:06:21.000Z","path":"2017/08/26/Linux/002. Linux系统的启动流程/","text":"GO 1. Linux系统的启动流程了解系统的启动流程，能够让我们在Linux系统在启动过程中遇到故障时，可以很快速地找到是在哪一步遇到了问题，这样我们就可以针对性地去排查故障。（以CentOS6系统为例说明） 1.1. 第一阶段：硬件引导启动 首先是BIOS加电自检，BIOS寻找启动介质，是硬盘还是光盘或者是其他启动介质。 找到启动介质后，在该介质中找到MBR。 MBR是启动介质（比如硬盘）的第一个分区的第一个扇区，大小为512字节。 其中前面的446字节是bootloader（CentOS安装的时候会在这里安装一个grub程序），紧接着64字节是分区表，最后面2字节是用来校验的，我们把它叫做55AA。 1.2. 第二阶段：grub启动引导程序 找到了MBR，就找到了grub，它就是一个引导程序，它会引导我们想启动的系统。（grub的配置文件是 /boot/grub/grub.conf，与/etc/grub.conf是软链接） grub引导分为两个阶段：执行stage1和stage2。 stage1是直接放在MBR中的，也就是前面446字节里面。 stage2比较大，所以被放在了文件系统里。 对于目前较新的文献系统（如ext4）来说，stage2是不能识别到的，所以在执行完stage1后，需要借助于一个中间桥梁stage1_5来识别stage2所在的文件系统，然后再执行stage2。 执行完stage2后，它就会去解析grub的配置文件 /boot/grub/grub.conf，在该配置文件中它又找到了内核和内核映像（initrd）的位置。 1.3. 第三阶段：内核引导 内核和内核映像（initrd）找到了，所以内核接管掌控权 按理说内核能够识别到几乎所有的硬件设备，但实际上内核的身材是非常小的，它只含有最基本的硬件驱动，而其它的常见硬件驱动是放在 initrd 中的。 所以这个阶段，initrd先释放到内存中，临时构成一个只读的文件系统，在这个只读的文件系统中，内核去执行临时文件系统里面的init进程，目的是加载各种硬件的驱动。 当所需的驱动加载完后，内核才挂载真正的根文件系统，内核把控制权交给了/sbin/init进程。 1.4. 第四阶段：系统初始化阶段/sbin/init 进程是系统其它所有进程的父进程，当它接管了系统的控制权后，首先会去读取/etc/inittab配置文件来执行相应的脚本进行系统初始化，如设置键盘、字体，装载模块，设置网络等。主要包括以下工作： 执行系统初始化脚本（/etc/rc.d/rc.sysinit），对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，到此系统算是基本运行起来了，后面需要进行运行级别的确定及相应服务的启动。rc.sysinit所做的事情（不同的Linux发行版，该文件可能有些差异）如下： 获取网络环境与主机类型。首先会读取网络环境配置文件（/etc/sysconfig/network），获取主机名与默认网关等网络环境。 测试与载入内存设备 /proc、 /sys 及 usb设备。除了/proc 外，系统会主动检测是否有usb设备，并主动加载usb驱动，尝试载入usb文件系统。 决定是否启动SELinux。 接口设备的检测与即插即用（PNP）参数的测试。 用户自定义模块的加载。用户可以在 /etc/syscongfig/*.modules 加入自定义的模块，此时它会加载到系统中。 加载核心的相关设置。按 /etc/sysctl.conf 这个配置文件的设置值配置功能。 设置系统时间（clock）。 设置终端的控制台字形。 设置 raid 及 LVM 等硬盘功能。 检验磁盘文件系统。 进行磁盘配额 quota 的转换。 重新以读取模式载入系统磁盘。 启动 quota 功能。 启动系统随机数设备（产生随机数功能）。 清除启动过程中的临时文件。 将启动信息加载到 /var/log/dmesg 日志文件中。 ==》当 /etc/rc.d/rc.sysinit 执行完后，系统就可以顺利工作了，只是还需要启动系统所需要的各种服务，这样主机才可以提供相关的网络和主机功能，因此会执行下面的脚本。 执行 /etc/rc.d/rc 脚本。 该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在 /etc/rc.d/rc*.d（*代表启动级别0~6）目录下，所有的文件均是指向/etc/init.d下相应文件的软链接。 rc.sysinit 通过分析 /etc/inittab 文件来确定系统的启动级别，然后才去执行 /etc/rc.d/rc*.d 下的文件。 注意：也就是说，/etc/目录下的 init.d、rc、rc*.d、rc.local和rc.sysinit 均是指向 /etc/rc.d 目录下相应文件和目录的软链接。我们以启动级别3为例来简要说一下： /etc/rc.d/rc3.d目录下的内容都是以S或者K开头的软链接文件，它们都链接到/etc/rc.d/init.d目录下的各种shell脚本。 S表示启动时需 start 的服务内容，K表示关机时需关闭的服务内容。 /etc/rc.d/rc*.d 中的系统服务会在系统后台启动，如果要对某个运行级别中的服务进行更具体的定制，通过 chkconfig 命令来操作，或者通过 setup、ntsys、system-config-services 来进行定制。 如果我们需要自己增加启动的内容，可以在init.d目录中增加相关的shell脚本，然后在rc*.d目录中建立指向该shell脚本的软链接文件即可。 这些shell脚本的启动或结束顺序是由S或K字母后面的数字决定，数字越小的脚本越优先执行。例如：/etc/rc.d/rc3.d/S01sysstat 就比 /etc/rc.d/rc3.d/S99local 先执行。 执行用户自定义引导程序 /etc/rc.d/rc.local。 其实当执行 /etc/rc.d/rc3.d/S99local时，它就是在执行/etc/rc.d/rc.local。前一个文件是后一个文件的软链接。 一般来说，自定义的程序，只需要将命令放在rc.local里面就可以了，这个shell脚本就是保留给用户自定义启动内容的。 完成了系统所有的启动任务后，Linux会启动终端或X-Window来等待用户登陆。 tty1、tty2、tty3……这表示在运行等级1，2，3，4的时候，都会执行 /sbin/mingetty，而且执行了六个，所以Linux会有六个纯文本终端，mingetty就是启动终端的命令。 除了这6个之外还会执行 /etc/X11/prefdm-nodaemon ，它主要启动X-Window。 至此，系统就完全启动完毕了。 2. 系统启动流程的示意图- Linux系统启动流程简图 - Linux系统启动流程详图 3. grub的配置文件3.1. grub配置文件说明grub的配置文件是 /etc/grub.conf，它的基本配置说明如下： default=0（1，2……）表示默认启动那个选项，可自定义 timeout=5 表示等待几秒进入默认的选项，可自定义 title后面的内容表示每个选项的标题，也就是在开机时候的各个选项的名字，可自定义 启动参数，最好不要改，改错了，就进不去系统了 3.2. grub加密 不加密密码的设置方式 在/etc/grub.conf配置文件中的title那行的上面添加一行”password=密码”即可 加密密码的设置方式 grub-md5-crypt grub-crypt --md5|--sha-256|--sha-512 用以上的命令来获得加密的密码，然后将其复制到/etc/grub.conf文件中的”password –md5|–sha-256|–sha-512 加密的密码”即可 说明：–md5|–sha-256|–sha-512 这三种只选一种即可 OK","tags":[]},{"title":"Linux配置静态IP联网","date":"2017-08-26T03:36:14.000Z","path":"2017/08/26/Linux/001. Linux配置静态IP联网/","text":"GO 1. CentOS6 的网络配置1.1. 获取IP、网关等信息安装好CentOS后，第一件事情就是配置IP，让机器连接网络，之后便能够通过远程工具（如Putty、Xshell、SecureCRT等）来进行管理了。 首先，可以用 ifconfig 查看网卡的IP等信息。 输入 ifconfig 后默认只有一个网卡的信息，即 lo 网卡，它是回环网卡，每个计算机都有这个网卡IP的，它的主要作用是机器内部通信。 可以用 ifconfig -a 来查看所有网卡的信息（包括未启用的网卡）。一般会显示名字类似 eth0 网卡的信息，这时候这块网卡还未启用，接下来我们应该启用它。 用 dhclient 让网卡自动获取一个IP。 这个命令是自动获取IP的命令，如果Linux所在网络环境有dhcp服务器，运行该命令后，Linux机器就可以自动获取到一个IP。（在服务器上用不到） 此时，这个IP是自动获取的，也就是动态的，实际机房的服务器IP并不是自动获取的，都需要固定好，所以，应该为eth0网卡设置一个静态IP。 在设置静态IP之前，先用 route 命令查到 NETMASK 和 GATEWAY，以便我们在设置静态IP时填在配置文件里。 route 这个命令是用来查看路由的。 route -n 可查看到网关。 还有一个命令可以查看到IP地址： ip add 配置网卡的配置文件 1.2. 配置网卡配置文件配置eth0网卡为静态IP，即配置该网卡的配置文件。 它的配置文件类似于 /etc/sysconfig/network-scripts/ifcfg-eth0 在这个配置文件中需要更改的地方有： 12345678ONBOOT=no 改为 yes //开机启动网卡BOOTPROTO=dhcp 改为 static //IP的类型，动态还是静态==&gt;新添加的几行内容：IPADDR=192.168.1.222 //这个IP地址是我们通过命令 ifconfig eth0 查到的。（之前通过dhclient命令获取的动态IP，可以自己填写为合适的IP地址）NETMASK=255.255.255.0 //子网掩码GATEWAY=192.168.1.1 //网关DNS1=202.106.0.20 //域名服务器的地址，目前的IP地址为联通的一个DNS服务器IP。DNS2=8.8.8.8 //可以添加多个DNS服务器IP，就像这样写成DNS1和DNS2 修改后的配置文件内容如下所示（一个例子）： 123456789101112DEVICE=eth0HWADDR=00:0C:29:B0:78:92TYPE=EthernetUUID=5efd98d1-d7b2-447f-9036-e4c73dfab70aONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.0.103NETMASK=255.255.255.0GATEWAY=192.168.0.1DNS1=4.4.4.4DNS2=8.8.8.8 1.3. 重启网络服务修改完配置文件后，需要将网络服务重启才能生效。输入下面的命令即可重启网络服务： service network restart 或者 /etc/init.d/network restart 1.4. 测试网络连通性通过 ping 命令来测试一下网络的连通性： ping www.sina.com 如果ping通了，就说明静态IP配置成功，并能连接外网了。 在Linux下ping会一直持续，需要按快捷键 Ctr+C 终止该程序。 2. CentOS7 的网络配置2.1. 获取IP、网关等信息 自动获取IP : dhclient 查看自动获取IP后是否可以联网 : ping www.sina.com 查看IP : ip addr 查看网关 : ip route 2.2. 配置网卡配置文件这一步是为了配置静态IP。 网卡的配置文件的名字类似于 /etc/sysconfig/network-scripts/ifcfg-ens33 在这个配置文件中需要更改的地方有： 12345678ONBOOT=no 改为 yes //开机启动网卡BOOTPROTO=dhcp 改为 static //IP的类型，动态还是静态==&gt;新添加的几行内容：IPADDR=192.168.1.222 //这个IP地址是我们通过命令 ifconfig eth0 查到的。（之前通过dhclient命令获取的动态IP，可以自己填写为合适的IP地址）NETMASK=255.255.255.0 //子网掩码GATEWAY=192.168.1.1 //网关DNS1=202.106.0.20 //域名服务器的地址，目前的IP地址为联通的一个DNS服务器IP。DNS2=8.8.8.8 //可以添加多个DNS服务器IP，就像这样写成DNS1和DNS2 修改后的配置文件内容如下所示（一个例子）： 123456789101112131415161718192021TYPE=EthernetBOOTPROTO=staticDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=18e90827-5eed-4b32-a5e1-3abdad76d8ccDEVICE=ens33ONBOOT=yesIPADDR=192.168.0.105NETMASK=255.255.255.0GATEWAY=192.168.0.1DNS1=119.29.29.29 2.3. 重启网络服务 重启网络服务 systemctl restart network.service 再查看IP检查是否正确 ip addr 2.4. 测试网络连通性 ping -c 4 www.sina.com 3. 网络初识补充内容3.1. 网卡名称说明 lo：回环网卡，只在本地使用 eth0：以太网卡，用以太网线连接 fddil：光纤网卡，用光纤网线连接 3.2. 常用的几个操作- 测试网卡接口与网线的连通性 mii-tool eth0 - 单网卡的关闭与启动 关闭：ifconfig eth0 down 启动：ifconfig eth0 up - 单网卡配置多个IP ifconfig eth0:1 192.168.1.2/255.255.255.0 - 永久更改主机名 在文件 /etc/sysconfig/network 内修改 HOSTNAME=字段 即可永久修改主机名。 - 查看路由表 route -n - 禁止PING实现方法如下： 临时 1echo 1 &gt; /pro/sys/net/ipv4/icmp_echo_ignore_all 永久 12修改 /etc/sysctl.conf 这个文件，添加如下一行:net.ipv4.icmp_echo_ignore_all = 1 - 开启转发实现方法如下： 临时 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 永久 12修改 /etc/sysctl.conf 这个文件，添加如下一行:net.ipv4.ip_forward = 1 - 查看端口查看服务器上开启了哪些端口：1netstat -antp 相关工具：nmap 3.3. DNS的配置文件- /etc/resolv.confDNS（NameServer）配置文件是 /etc/resolv.conf。 该文件的内容如下（一个示例）： 123generated by sbin/dhclient-scriptnameserver 8.8.8.8nameserver 220.181.137.37 如果我们是dhcp自动获取的IP，那么它会自动在/etc/resolv.conf里获取dns的ip，如果我们手动编辑该配置文件，那么重启网络服务后还会自动还原，因为我们打开了dhclient的服务，所以为了不让它受dhclient的影响，我们需要杀死dhclient：killall dhclient，同样也需要杀死NetworkManager进程； 默认需要我们在网卡配置文件（/etc/sysconfig/network-scripts/ifcfg-eth0）重定义DNS服务器的IP，但如果在网卡配置文件中加上 PEERDNS=no 后，则该配置文件中的DNS1= 语句失效。 - /etc/hosts/etc/hosts 文件是一个简易的DNS服务器，在该文件中添加IP和域名，即可在本地实现DNS的功能。 OK","tags":[]},{"title":"Linux在线帮助的使用","date":"2017-08-25T04:38:43.000Z","path":"2017/08/25/Linux/000. Linux在线帮助的使用/","text":"GO 1. 命令执行错误信息当我们执行一条命令的时候，发生了错误，一般会在屏幕上面显示该错误的信息，我们可以通过这个错误信息来寻求解决办法。 1.1. command not found我们遇到最多的错误大概就是这个command not found了，它的意思是命令找不到。通常出现这个错误的可能原因如下： 这个命令不存在，因为该软件没有安装之故，解决方法就是安装该软件。 这个命令所在的目录目前的用户并没有将它加入命令搜索路径之中，请参考bash的PATH说明。 打错了命令。 2. man pageman 命令 即可查看关于所查命令的相关帮助信息，命令正确执行后进入的页面称为”Man Page”。我们可以用man man来查看man命令的使用。 2.1. 指令数字代表的意义在Man Page的第一行，命令名称的后面的括号里面的数字，是有意义的，它们可以帮助我们了解或直接查询相关的资料。它们的意义代表如下: 代号 代表内容 1 使用者可以操作的指令或可执行文件 2 系统内核可调用的函数与工具 3 一些常用的函数（function）与函数库（library） 4 设备文件的说明 5 配置文件或某些文件的格式 6 游戏（games） 7 惯例与协议等，如Linux标准文件系统、网络协议、ASCII等等的说明 8 系统管理员可用的管理命令 9 跟内核有关的文件 2.2. Man Page的主要内容 代号 内容说明 NAME 简短的命令、数据名称说明 SYNOPSIS 简单的命令的语法格式 DESCRIPTION 较为完整的说明，这部分最好仔细看看 OPTIONS 针对SYNOPSIS部分中，有列举的所有可用的参数说明 COMMANDS 当这个程序在执行时i，可以在此程序中下达的命令 FILES 这个程序或数据所使用或参考的某些文件 SEE ALSO 可以参考的与其相关的其它说明 EXAMPLE 一些例子 BUGS 已知的BUG AUTHORS 作者 COPYRIGHT 版权协议 2.3. 在Man Page中的按键操作 按键 进行的工作 空格键 向下翻一页 [Page Down] 向下翻一页 [Page up] 向上翻一页 [Home] 去到第一页 [End] 去到最后一页 /string 向下搜索 string 这个字符串 ?string 向上搜索 string 这个字符串 n,N n表示继续搜索，N表示反向搜索 q 结束这次的Man Page 2.4. 通常用man的方式通常在查阅某个数据时是这样来查阅的： 先查看NAME的项目，大略看一下这个数据的意思。 再仔细看一下DESCRIPTION，这个部分会提到很多相关的资料与用法，从这个地方可以学到很多小细节。 而如果这个命令其实很熟悉了，那么主要就是查阅关于 OPTIONS 的部分了。可以知道每个选项的意义，这样就可以执行比较细部的命令内容。 最后会再看一下跟这个资料有关的还有哪些东西可以使用的。也就是SEE ALSO项目。 某些说明内容还会列举有关的文件（FILES 部分）来供我们参考。这些都是很有帮助的。 2.5. man page的数据文件man page的数据文件通常放在/usr/share/man这个目录里，然而我们也可以通过修改它的man page查询路径来改善这个目录的问题。修改/etc/man.config(有的版本为man.conf或manpath.conf)即可。 2.6 man的其它用法2.6.1. man -f-f选项可以获取更多的信息，如下：123# man -f infoinfo (1) - read Info documentsinfo (5) - readable online documentation 然后可以用相应的数字来查看特定的信息：1man 1 info 2.6.2. man -k-k选项的作用是，在系统的说明文件中，只要包含后面的关键字就将该说明列出来。如下所示：1man -k man 2.6.3. 与man有关的两个命令 whatis [命令或数据] 等同于 man -f [命令或数据] apropos [命令或数据] 等同于 man -k [命令或数据] 需要注意的是，这两个特殊命令要能使用，必须要创建whatis数据库才行。这个数据库的创建需要以root身份执行这个命令: makewhatis 3. info page3.1. info的介绍基本上，info与man的用途差不多。与man不同的是，info page是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来跳到各不同的页面中，每个独立的页面也被称为一个节点（node）。所以，你可以将info page想成是命令行模式的网页显示数据。 不过你要查询的目标数据的说明文件必须要以info的格式来写成才能够使用info的特殊功能（例如超链接）。而这个支持info命令的文件默认是放在/usr/share/info/这个目录下。 使用info info可以得到如下的界面：123456789101112131415161718192021222324File: info.info, Node: Top, Next: Getting Started, Up: (dir) Info: An Introduction********************* The GNU Project distributes most of its on-line manuals in the \"Infoformat\", which you read using an \"Info reader\". You are probably usingan Info reader to read this now. There are two primary Info readers: 'info', a stand-alone programdesigned just to read Info files (*note What is Info?: (info-stnd)Top.),and the 'info' package in GNU Emacs, a general-purpose editor. Atpresent, only the Emacs reader supports using a mouse. If you are new to the Info reader and want to learn how to use it,type the command 'h' now. It brings you to a programmed instructionsequence. To read about advanced Info commands, type 'n' twice. This bringsyou to 'Advanced Info Commands', skipping over the 'Getting Started'chapter. --zz-Info: (info.info.gz)Top, 52 lines --Top------------------------------------Welcome to Info version 5.1. Type h for help, m for menu item. 3.2. 第一行的说明info page的界面里，第一行显示了很多信息。第一行里面的数据意义如下： file：代表这个info page的数据是来自info.info文件所提供的。 Node：代表目前的这个页面是属于Top节点。意思是info.info内含有很多信息，而Top仅是info.info文件内的一个节点内容而已。 Next：下一节点的名称为Getting Started，你也可以按N到下一个节点去。 UP：回到上一层的节点总览界面，你也可以按下U回到上一层。 Prev：前一个节点。但是由于Top是info.info的第一个节点，所以上面没有前一个节点的信息。从第一行你可以知道这个节点的内容、来源与相关链接的信息。 3.3. info page 中的按键说明 按键 进行工作 空格键 向下翻一页 [Page Down] 向下翻一页 [Page Up] 向上翻一页 [Tab] 在节点之间移动，有节点的地方，通常会以*显示 [Enter] 当光标在节点上面时，按下回车键就可以进入该节点 B 移动光标到该info界面当中的第一个节点处 E 移动光标到该info界面当中的最后一个节点处 N 前往下一个节点处 P 前往上一个节点处 U 向上移动一层 S（/） 在info page当中进行查询 H 显示帮助菜单 ? 命令一览表 Q 结束这次的info page 4. 其它有用的文件一般而言，命令或者软件开发者都会将自己的命令或者是软件的说明制作成“在线帮助文件”。但是，毕竟不是什么都需要做成在线帮助文件的，还有相当多的说明需要额外的文件。此时，这个所谓的How-To（如何做）就很重要了。还有，某些软件不仅是告诉你“如何做”，还会有一些相关的原理会说明。 那么这些帮助文件放在了哪里呢？就是放在/usr/share/doc这个目录下。所以说，你只要到这个目录下面，就会发现有很多的说明文件，还不需要到网上找数据。而且这个目录下面的数据主要是以软件包为主的，例如GCC这个软件包的相关信息在/usr/share/doc/gcc-xxx（那个xxx表示版本的意思）中。 5. 总结 有些信息可在屏幕上面获取。 在命令行界面下，有任何你不知道的命令或文件格式，但是你想要了解它，都可以使用man或者info来查询。 而如果你想要架设一些其它的服务，或想要利用一整套软件来达成某项功能时，请赶快到/usr/share/doc下面查一查有没有该服务的说明文档。 另外，再次强调，因为Linux毕竟是外国人发明的，所以这些帮助文件主要是以英语为主。需要学习一下英文来提高英文的阅读能力。 OK","tags":[]},{"title":"《空城纪》许嵩和栈弈","date":"2017-05-20T13:31:40.000Z","path":"2017/05/20/转载/001. 《空城纪》许嵩和栈弈/","text":"空城纪『序』整整一年没有写长篇故事了。 一般所谓长篇，就是把一个短篇塞进去很多无关紧要的废话而后兴致勃勃地发表。 可能比较无聊。 可恰好的是，我们都很无聊，需要这种无聊的东西来打发无聊的时光。 去年写《奇迹》，打发了一代人的无聊时光。每天在打完cs脸颊红扑扑的状态下被迫去写上2000字满足大众需要。后来由于文章内死人太多，遭到抨击，加之大学开学。不了了之。 姑且。 今年就在这儿写点东西。想起来了就写了。想不起来了就不写了。这没什么好奇怪的。就像你想起来上厕所了就上了，看到老情人一激动忘了就忘了。水喝多了尿床了就尿床了。虽然我文思如尿崩的时代已然过去。 可以看成小说，可以视为纪实。并不重要。我和栈弈的一些遭遇或者美遇，都要在这渐次上演。 语文老师说过。人物只是线索。 这是对了。 写文章如果不是我。写得如果不是我和栈弈及其他一切周遭人等，该发生的仍旧发生。如同桡尺关节始终是处于桡尺骨结合处。 一任的无聊。 我们处在一个背信弃义类似野狗上青天的时代。 周遭的一切何等荒芜乃至于觉得什么都没有。 什么都没有。代表着什么。他？的。 项羽火烧了阿房宫。咸阳城外风化成一片荒冢。 叫做空城纪。 ————Vae 空城纪『一』说到我和Vae的相遇…恩，先不说这个，既然Vae在序言里迟迟不让栈弈出场，礼尚往来，正式开始的第一篇里还是由栈弈来唱一出独角戏吧。 对于以后将要胡扯的这一系列故事而言，起点应该是2004年的9月，全国各地的各种大学纷纷红着眼睛收钱收学生的时段，而我步入大二。 混迹于学校本部一年的我和其他人一起搬到了学校新区。新校区位于大学城的边缘，而大学城位于这个城市的边缘，具体方位是靠近两座山的地方，一座大蜀山，一座小蜀山，大蜀山是公园，小蜀山是公墓。 我们来到新区后，对这个狭小偏僻的地方感到很大的失望，具体失望之处会在今后慢慢解析。有一日班里某君在操场南面的小树林西面的小土包后面的一个旮旯处发现一只皱巴巴的保险套，于是我们相信这里已经是野外了。 我们开学较早，在我们刚刚开始感受旷野大风吹的时候，Vae以及即将与他同窗的其他人物正在各自的家里享受着最后的安逸，可能还夹杂着对大学生活的些许憧憬。当然，这无可厚非，？？？说过，想知道梨子的滋味，就要改造它，亲口尝一尝；同样的，想知道上大学的滋味，就要被它改造，让它上一上。所以在这之前，你可以肆意的幻想，我也相信一切皆有可能，就如同一个梨子吃下去，可能你止咳化痰，也可能你痢疾拉肚。 别介意，Vae讨论完文思和尿崩的关系之后，我又探讨了大学和痢疾的关联，因为栈弈和Vae总是会有一些相同的地方，而其中一个，就是我们都在这所医科大学里念着无法做医生的专业，叫做卫生管理。 这个名字乍听起来很容易让人想到是医院里管理卫生的，传说我们所在的是全国第一所卫生管理学院，还传说后来在复旦南大中山大等等高级场所开设卫生管理专业的人，都是出自于我们这里，而实际的情况是，用人单位更愿意要他们的学生。就好比合肥万燕出现了世界上第一台VCD，而我家买的VCD却产自广东爱多，这样的现象可以归结成一句朴素的话：“个人富不算富，全村富才算富”。 当我已经渐渐习惯了在这样一个新的环境里继续翘课和懒觉事业的时候，忽一日，整个校区旌旗飘扬，原来新生将至。 每一年大学里新生报到的时候都有老生前来迎接的传统，一帮人摆好桌椅，竖好牌子写上自己学院的名称，然后新生即可以对号入院，这样的活动会持续两天。看起来这样的形式可以给新来的学子以夏日的清凉，而实际上，前来迎接的男生或女生都在期待接到一个貌美如花的女子或者玉树临风的男子，然后开始一段恋情。对于刚刚跳出情感旋涡的栈弈自然不会参与这样无聊的活动，于是我选择在这两天回家修养生息，以备即将到来的补考。 修养的第二天上午即将中午的时候，我被一个来自学校的短信惊醒，内容是“快来吧，来看看今年的女生都丑成什么样了！”真的是莫名其妙是不是他在搞笑，丑难道是我造成的不成？但是出于好奇我乘坐一个小时的公车来到了学校看看有多丑，我到达的时候被告之新生已经差不多全到了，看见新丑的机会减小，于是我就坐在接待处跟他们哈起牛皮。这时候很多人从食堂吃饭出来，辅导员告诉我说：拿饭缸的都是新生。 就在此时我听说了一个上午来的新生，一来就抽了他的辅导员，（名词解释：合肥地区“抽”即“骂”之意。）其他流传关于这厮的事情还包括：合肥一中毕业、男性、穿着嘻哈、裤子里可以放一只老母鸡（当然，并没有看见放过）、长发、戴眼镜、镜片兰色、获过省里网页制作大赛一等奖。大家对他的评价是：等着死吧。 那天晚上，我和辅导员一起吃饭，白天那个不幸被抽的辅导员也有幸在场，大家对今年的新生展开新一轮探讨，但是没有进展，依然总结为女生太丑，男生比较丑。而且还有一个网页大赛获过全省冠军的沦落至此，那个辅导员在说这个的时候很显得自豪，全然不顾白天曾被其抽。我随口一问：那个一中的是吧？结果被告知：不，工大附中的。 工大附中？我的母校。 于是栈弈和Vae的另一个共同之处被发掘出来。 再于是，第二天的中午，栈弈出现在Vae的寝室门口。 再再于是，对于以后将要胡扯的这一系列故事而言，起点似乎应该是2001年的9月。 ————栈弈 空城纪『二』在我小时候的记忆里，合肥是一个很小的地方。因为大人告诉过我，从我家到外婆家，不过十公里。骑自行车50分钟就到了。而我家在一个大人们称之为南门的地方，外婆家在一个它们叫做北门的地方。这一南一北的，才十公里，算算老子也就呆在一个一百平方公里的破地方啊。十八岁那年暑假的时候坐在电脑前面认识了一个之前完全不认识的女子，并于二十天后见面，二十二天后发展为男女朋友。这个事情告诉我，合肥真的很小。 我一直希望我能有一个既可以文静的陪我讨论诗文转个身又可以疯狂的陪我去吃去疯去野的美丽女人。可正是现实和理想的差距激励我不断奋斗，没有这样的人。他们告诉我，你这种想法，在古代直接把一个稍微念过几年书的青楼女人赎回家就可以了，而且你是学医的，可以试图把她身上的百病治好，让夕阳飞翔。这让我感到沮丧。其实很多东西都只是一种美妙的愿望，这个愿望的深究，始终是一场残念。 我用二十二天发展的那个女性。她不能陪我讨论诗文。导致我满腹经纶无处投递。她不能陪我疯狂的玩，导致我万千激情无处爆发。然而，我却要死要活的爱上她。我无法证明如果出现一个符合我理想要求的女性的时候我是否会义无反顾的抛弃她，然而算命书上说，你们俩的恋情，一共只有一年，并且是四世轮回。 九月中旬开始的时候，我痛苦的在qq里面和她惜别，因为我要去一个通过我十二年的在校不努力学习考取的一个中不溜的本科院校。之前的大人很兴奋，不断的有人给我钱，向我祝贺，我也在家接了很多电话，家里也请客吃饭。也就是说，老子考取了大学，是和这些人的大力支持分不开的。尽管我不知道谁谁谁是谁谁谁。而她也将奔赴另外一所高校报到。我们感到空气很悲凉。其实哪怕是去北大报到，我仍然感到悲凉。因为所谓学校，无非是一个限制你的地方。尽管校方会卑劣的表示，我们限制了你的人身，但解放了你的思想，当你四年出来之后，你的人生将被重新定位，你会带着母校的思维方式与人文气息与人打交道，走到哪儿，你都是我们的人。 走到哪儿都是你的人。这不是强女干吗。 但我相信，一切都会过去。学校始终阻挡不了我什么。就像我就读的高中，那个号称今日我以x中为荣明日x中以我为荣的傻x学校，沽名钓誉搞了一大堆封号，尽管实质上平庸无奇。其间我不断的旷课，偶尔的上课，没有受到任何相关的处罚。可能是因为教师比较忙。忙于赚钱之余，偶尔管理一下好学生以及部署好家长会等等表面工作，年底的时候因为表现突出获得优秀教师称号，来年以此称号抬高身价，继续赚钱。一般开个小辅导班能搞个30号人，每晚一人交个五十来块；如果要单独辅导，那么一晚估计得三五百才能拿下。这很像古代的青楼女子，被某位达官贵人相中了睡了一晚，之后再想让她出场简直难于上天。如果和微服嫖女昌的皇帝睡了一晚，那么直接晋级为妃子，成为对口陪睡。所谓师风日下，其实是错的，因为我没有看过师风向上的时候。 总的来说。我的生活态度是积极的。那些因为看破红尘而悲观失望的傻x其实是因为根本没有看破，因为无论怎么样，人都是要死的，哪怕这世界上再多的东西让你不爽或者爽。反正是迟早的事，不如尽量自寻快乐。 于是，我很积极的跑去我即将待上四年的学校报名。校内平庸无奇，毫无学术氛围，很多骑三轮车的，卖棉花糖的，残废的，老的路都走不动的，花枝招展如女支女的都在里面穿梭。该校四通八达，到处都是门，俨然成为？？？？，很多人抄近路都要从校内经过一下。这令我欣慰，因为这意味着我可以在以后旷课的岁月里从任何角度逃跑。再往里面走，人山人海，一大堆和我一样大的家伙面带激情的在报名处交钱，每个人身后跟着自己的家长。这气氛令我感到无所适从。我只想抓紧时间交钱走人。于是我抓紧时间，交钱，走人。其间冷言讥讽据说将成为我今后班主任的一个男性。事后我有一丝恐惧，因为这意味着可能在我今后旷课的时候，他会对我进行空前严厉的制裁。 回家的时候路边的花草依然如故。我很怜爱的摸摸饲养三年的小犬，郑重的告诉他，我明天要走了，去一个你一辈子也去不了的地方。你要好好的过活，如果我一年之后回来你死了，我会让你死无全尸。 说这话的时候我不知道，在之后的一年内，我在家的时间和在校时间是基本持平的。 所有的算命书上都写道在我这天出生的属虎的男性是先知。虽然我从未让自己的先知功能为我服务，但是实践证明了，很多时候，我确实具备了一定的预见性。就像这场戏，从入学的一刻，它的结果就已经是注定了的。 稍候的几天里我完全沉浸在爱情的美妙中，并且珍惜每秒钟发短信的时光。因为在这儿谁也不认识。我谁也不想认识。当时的想法是，有老婆就够了。再加上军训是一种非常无聊的东西，每天在那儿傻站，然后评定哪个排站的好，站的久。傻的一塌糊涂。至于能增强身体素质那完全是扯淡，全去当兵好了，念什么书。秀才和兵做的事情总是两样的。要是真有所谓的全面发展，那只能是普遍低级的全面发展。尽管很多人觉得我是全面的发展的。但实质上，我发展的都在一个领域内，并且都是些安静的项目。虽然我看起来不太像文人。室友跟我说我看起来更像坏人。这令我感到满意，并且非常。如果是什么人都可以用肉眼看出来，岂不是毫无悬念。世上的乐趣也因此少了很多。 带我们军训的排长也极度空虚，并且略有文化，每天晚上要与我就人生进行高谈阔论，并且至凌晨三四点。经常室友起夜撒尿看到我们仍然在长谈，唏嘘不已。虽然，我每天都很困乏，并且想尽方法逃脱，比如，逃跑至栈弈处。 栈弈是我认识的第一个非本年级的人。认识当天我正沉迷女色，给女人发完短信打完电话，并对谈话内容进行温习，小脸红扑扑。栈弈非常严正的表情敲敲门，问我是不是叫xxx，并且在手心写下他的名字告诉我。这令我感到非常之正式，虽然我不知道他怎么知道我是谁，也许他也不知道我不知道他怎么知道我是谁。一切都不那么清楚明白。宗旨是，我们认识了。之后接触到的很多事，都不那么清楚明白，这渐次令我习惯。很多时候我不清不楚的获得了。或者不清不楚的失去了。尽管这些同等令人唏嘘。 ————Vae 空城纪『三』合肥的季节气候，是过了冬天就是夏天，过了夏天就是冬天。在那个骄阳似火的新生报到日过后，天气就一天比一天冷，这样的天气很适合睡眠，每日只醒来一次明显不够，往往早晨的第一次醒来都带着淡淡的寒意和尿意，非常愉快，然后便情不自禁地继续睡眠。一般的情况是室友下课回来后把我唤醒，更衣漱洗完毕后，我会去食堂随便搞点吃的，填饱肚子就行了，我对食堂的要求就这么点，只要不限制我的食欲。下午如果没有课的话就不去食堂，而是直接带着兜兜里的一元硬币步行十几分钟来到公交车站乘车回家吃午饭，晚上再乘车回来。 这样的作息让我受益无穷，可以省下早饭的钱来充当日常零花，不足之处是有老师在教室点名的可能和被楼管查到的危险。有一天早晨，当我像往常一样快乐地在床上翻滚的时候，突然传来了敲门的声音，我顿时很警觉，寻思应对法则，正当这时，门外传来一声呼唤： “栈弈在么？” 我用迷朦的双眼仔细辨认了一番，赫然看见Vae站在门外，他不知用什么方法逃避了军训，我们可算做这个校园里偷偷摸摸的两个自由人吧。我穿着个小裤衩顺梯爬下床，套个汗衫，给他倒了杯水，他说不喝，只是想来看看我们的杂志。 这个学院里充斥着各种各样的社团，其中比较著名的，也是在日后对我们的生活拥有影响的只有三个社团，文学社、演艺社、还有一个自虐会。自虐会学名自律会，就是学生代替老师每日上课实行点名夜里实行查房的学生自我虐待组织，是老师和学生的桥梁。演艺社和文学社则顾名思义，栈弈当时正在文学社混着，刚刚完成一本杂志的编印，或许这吸引了Vae的视线，让他冒死逃避军训来阅览杂志。我打算把他吸收进文学社来。 在后来几日的相处中我们逐渐认识了一些周边的人，比如我认识了大棒，比如Vae认识了胡子。 胡子的特征是没有胡子，我进入这所大学的时候他正在上大四，第一次见面是在文学社的招新面试上，我想进入文学社的网络部，当时我站在台上，和考官一问一答。 考官问我：你有什么爱好？ 我回答说：我爱好文学（这显然是必选项），我还爱好上网，还爱好美女。 考官又问：为什么选择我们的网络部？ 我回答说：为了满足我这三大爱好。 面试结束后我就被胡子找去，他声称我已被录取，俨然都是他的功劳一般。 而我则认为有没有他我都会被录取。 因为如果不录取我显然是他们的损失。 而面试的当天就真的有一个人在台上说“你们不录取我那将会是你们的损失”。 结果是，此人被损失。 而胡子，是个神秘的人，从不抽烟却一口能灌下半瓶白酒而面不改色，有个众人称美的女友却从不见两人同行，他会出现在学校里的所有场所却从未在宿舍楼里见到，最为神奇之处在于，不管你在学校惹了多大的麻烦，都可找他解决，大到被人追砍，小到旷课被捉。 胡子快毕业的时候找工作找的十分辛苦，坐着飞机在全国各地飞来飞去，结果是愿意要他的他看不上，看上的又不愿意要他，原因是他四级没过，我很纳闷这样一个神通广大的人为何无法将自己的四级搞定。记得我大一刚刚夏天的一个夜晚，胡子躺在学校？？？？边的草地上，破例地抽起了烟，半晌吐出一句话——“英语要搞好”。 后来的现实证明这句话对我毫无效应。在那个夜晚大约四个月后，胡子摇身一变，成为了Vae他们的辅导员，并在上任第一天受到Vae的冷遇。 再说大棒。 大棒是在Vae寝室认识的，平时睡在Vae对面，黑黑的，宽厚身板，淳朴憨厚的样子，据说来自北方的一个小县城。后来的一个夜晚在水房冲凉的时候遇见他，我顿时明白其名字的由来。在后来的日子里大棒的憨厚让我十分满意，而更令我满意的是大棒结实的身板，于是萌生将他也拉进文学社的想法，这样今后举办什么活动的时候，搬运桌椅的工作将可以顺利完成。不料谈及此事的时候被告知演艺社的人已经捷足先登，大棒已经对其社长死心塌地，决意要加入演艺社而后快。而原因仅仅是该社社长与大棒第一次见面时发了一根烟给他，这让大棒觉得很受尊重。 这是我第一次对大棒感到失望。 同样在Vae寝室认识的还有一个叫宁飞的男生，但与Vae并非室友关系，而是自虐会新发展的小会员，已然上阵来寝室查房了。早在新生报到那天晚上收摊的时候，此人就曾跑来向我询问如何加入自虐会，我对这种问题的答案是无可奉告，为的是少一个被此社团毒害者，不料此人无师自通自学成才找到组织。 此人与Vae竟然还是老校友。 作为已经大二的我深切知道大一的生活是苦闷的，这种苦闷比起高三只有过之而无不及，高三苦闷的时候我会听忧伤的歌曲来配合心情，极其小资。而大一连听歌的兴趣也消失，极其厌恶小资。整天只无精打采，每天零点到十二点睡觉，十二点到零点等待睡觉。 正因为如此我才会对和我同出于工大附中的Vae关爱有加，虽然他是借读在另一所重点高中而并未在工大附中读过一天书，但总比毫无联系的强一些。一个星期四，我对他无微不至的关怀终于得到回报，他声称邀请我出来会餐。 这次会餐对我们意义重大，因为在进食的过程中我得知他现在的女友是花费二十二天得手的，而此女是我高中时曾喜欢过的。得知这个真相之后我很迷茫了几秒钟，不知这个朋友是否能继续做下去，而几秒钟之后，胡子的音容笑貌浮现在我的眼前，我看见他说：“女人永远只能带来烦恼，而兄弟却可以借钱给你。”于是我豁然开朗向Vae 表明态度，然后我们饭扒得更欢了。 记得我高中时候的学校边上有一个网吧，起名叫做“地球村”，基本上任何时间进去都会遇见各种各样的熟人，应证了网吧的名字。有一种我们称之为宿命的东西，矫情一点说是缘分。我在怀疑我生活的地方是否真的很小，每次上街我都会遇见超过两个的熟人。但是曾经有一个让我爱得死去活来的女子，在她从我生命中消失之后我始终认为可以再见一面，却至今没有再遇见，一直到她的容颜由模糊变的清晰，然后再模糊。我始终感觉，当真正爱一个人的时候是记不得她的长相的，即使你们白天刚刚见过。当她的样子慢慢清晰，我慢慢的不再爱她，当她的样子再一次模糊，一切都已尘埃落定，我们只是命运里的路人，恰好有一段同路的旅途而已。 以上的问题可以归功于中国的人口问题，林子大了才会什么鸟儿都有，天下之大才会无奇不有，大千世界才会万象更新，因为人多，我每次上街遇到两个以上的熟人，因为人多，她被人海淹没。 有些事情就是这样，看起来平庸无奇，细想颇有玄机。相遇本是必然，但是为什么单单我们相遇，好象前世欠下的一般。无规律的点放射着无规律的射线，然后相交，然后相依为命狼狈为奸欢天喜地歇斯底里。公交车上坐过同一个位子的两个人，QQ上同时上线的两个人，打错你电话的人，你们毫无关系，你们却如此贴近，上帝安排好了一切还是一切都没有安排？ 尽管结果都是一样。 有些人或许你们本该相遇，但是却匆匆来去；而有些人或许本该相逢如萍，但是却日久生情；有些关系或许不该太近，但是却命中注定；有些关系或许无法逃避，但是却走近默剧；有些时候你感觉胜利在即，却发现一败涂地；有些时候你感觉尚有转机，却发现缘分已尽；有些事情根本不该提起，却又刻骨铭心；有些事情根本应该忘记，然而无能为力。寥寥几人，走进空城，演绎悲欢，拼剪情节。人员各就各位，空城纪由此展开。 ————栈弈","tags":[]},{"title":"《断舍离》","date":"2017-04-25T09:08:34.000Z","path":"2017/04/25/Reading/002. 《断舍离》/","text":"GO 该书作者：[日本]山下英子 1. 目的 通过学习断舍离，将会重新审视自己与物品之间的关系，从关注物品转换为关注自我——我需不需要，一旦思考，并致力于将身边所有“不需要、不合适、不舒服”的东西替换为“需要、合适、舒服”的东西，就能让环境变得清爽，也会由此改善心灵环境，从外在到内在，彻底焕然一新。 断舍离非常简单，只需要以自己为而不是物品为主角，去思考什么东西最适合现在的自己。只要是不符合这两个标准的东西就立即淘汰。 2. 方式 断舍离就是通过收拾自己居住的房间，让自己从看得见的世界走向看不见的世界的境界。 因此，要采取的行动是： 断 —— 断绝想要进入自己家的不需要的东西 舍 —— 舍弃家里到处泛滥的破烂儿通过不断重复断和舍，最后会达到这样的状态： 离 —— 脱离对物品的执念，处于游刃有余的自在的空间。 3. 说明补充 要从时间轴和关系轴来看物品。时间轴要定在当下，关系轴要定在自己的需要上。 3.1 筛选物品带来的自我觉察 这种改变的机制是这样的：要得到“这种东西与当下的我很相称，对当下的我来说是必需品”这样的判断，人就必须要清楚的了解自己。通过不断地筛选物品的训练，当下的自我就会越来越鲜明地呈现在自己的眼前，人也就能以此判断出准确的自我形象。 不但确保每样物品都在自己的掌控之下，自己能确实用到它，还要和它成为好朋友——和自己喜欢的东西生活在一起。这样的话，就是达到了“断”。在买东西的时候会反复思量，让物品物尽其用，并且确保能把它的功效发挥到极致，一直到用完。这就是断舍离的最终阶段。 3.2 三种扔不掉东西的人 逃避现实型 执着过去型 担忧未来型 3.3 破烂儿可以分三类 不用的东西漫不经心地保存或放着不管的东西，甚至是已经忘了它的存在的东西，是因为一想到扔掉就心怀不安所以就一直拖着没扔掉的东西。 还在用的东西好歹还算是在用，可其实并不喜欢，所以就随便使用着。我们会乱七八糟地乱放，毫不珍惜地随意乱用这些东西。 充满回忆的东西因为充满了怀念与回忆，所以总也丢不掉，是拥有强大能量的东西。 需要注意到的就是 把自己用不着的东西送给有需要的人时，要说“请收下”，不能说“给你”。 4. 画面美感的要求 物品要用才有价值。物品就在此时、当下，应该出现在需要它的地方。物品处于恰当的位置，才能展现美感。 OK","tags":[]},{"title":"《一万小时天才理论》","date":"2017-04-25T06:58:05.000Z","path":"2017/04/25/Reading/001. 《一万小时天才理论》/","text":"GO 该书作者：[美国]丹尼尔·科伊尔 序 10000小时法则。这一法则是由20世纪70年代的心理学家们提出的，他们认为所有的世界级专家（从作曲家、外科医生到足球运动员）都需要经历10000小时（一般超过10年）的刻苦练习。 10000小时法则的关键在于：没有例外之人。没有人仅用3000小时就能达到世界级水准；7500小时也不行；一定要10000小时——10年，每天3小时——无论你是谁。 才能密码建立于颠覆性的科学发现之上，其中涉及一种叫做髓鞘质（myelin）的神经绝缘体，一些神经学家们称它为学习技能的圣杯。当我们开启神经回路的方式正确（练习正确的挥棒姿势或者弹钢琴）时，髓鞘质就给神经回路包上绝缘体，髓鞘质越厚，绝缘性就越强，我们的动作和思维就越加精确和敏捷。 髓鞘质的重要性体现在一下方面。一是普遍性，每个人都有髓鞘质，虽然小时候生长速度最快，但确实一辈子都在生长。二是通用性，髓鞘质的生长有利于所有类型的技能，包括智力型和体力型。三是无形性，髓鞘质看不见摸不着，只能在恰当的时机才能感受到。但是最重要的是，人们了解了髓鞘质这个新模型，就能清晰地理解技能。投入有效练习地时间和精力越多，就能越块掌握技能。 一万小时天才理论地三大要项：即精深、激情、伯乐。如何融合这三大要项正是掌握技能地关键，少了一项就会减慢这个过程。融合三者，哪怕只有6分钟，事情就会不一样。 第1章 精深1. 冒牌哈佛 谁也不能岁随随便便成功，它来自彻底的自我管理和毅力。——哈佛图书馆训言犯错让你更聪明。——德国寓言 精深练习是建立在一个悖论之上的：朝着既定目标挣扎前进，挑战自己的能力极限，不断犯错，会让你更聪明。类似的说法是，做哪些不得不放慢节奏的事情，犯错并加以改正——就像爬冰山，刚开始的时候会滑倒，会跌跌撞撞，最后会不知不觉中就变得敏捷自如。 精深练习是一个奇怪的概念，理由有二： 它违背了人们对“人才”的第一印象。（常识中与生俱来的天赋很重要，但其实是后天的精深练习更重要） 精深练习需要犯错，才可以转化为技能。谁也不能岁随随便便成功，它来自彻底的自我管理和毅力。——哈佛图书馆训言 2. 才能细胞 我一直认为，除了傻子，人在智力上差别不大，不同的只是热情和努力。——查尔斯达尔文 有两个原则，可以理解技能和髓鞘质之间的关系。 实际上，所有动作都是神经纤维链之间沟通的结果。 技能线路锻炼得越多，使用就越自如。 髓鞘质的原则 回路放电至关重要。髓鞘质不会凭着天真的愿望、模糊的想法，或者哪些洗个热水澡就忘光光的东西而生长。这种生理机制只钟情行动：真真实实的电流脉冲传过神经纤维。它钟情坚持重复。精深练习的动力来自原始状态，即时刻警、忍饥挨饿、目标明确，甚至绝望挣扎的状态。 髓鞘质包罗万象。以不变应万变。髓鞘质并不知道自己会被谁拿来使用，是（棒球的）游击手？还是舒伯特乐章的演奏者？无论何种用途，它的生长遵照同样的规则。髓鞘质一视同仁：哪条回路开启了，哪条回路就会包裹上绝缘体。髓鞘质不在乎你是谁，只在乎你做了什么。 髓鞘质无法逆转。髓鞘质化就像铺路，只朝一个方向前进。一旦技能回路包裹上了绝缘体，你就无法去除这层绝缘体（除非年龄或疾病）。这就是为什么习惯很难打破。改变旧习惯的唯一办法就是重复新动作以养成新习惯。 髓鞘质与年龄。儿童时期，髓鞘质会一波接一波地生成，有些由基因决定，有些与活动相关。这个状态一直持续到30多岁，为人类提供了一个轻松掌握新技能地关键期。此后，髓鞘质还会继续生长。直至50岁，损失地速度将快过生长地速度。人的一生都能够髓鞘质化——值得庆幸的是，5%的磷酸寡核苷酸一直出于处于不成熟状态，随时待命。但是，假如有人希望在晚年学习一门语言或一样乐器，那么他会发现，为生成必要的回路所付出的时间和汗水要多得多。这就是为什么绝大多数世界一流的高手自幼就进入该领域。他们的基因并没有随着年龄的增长而改变，只是生长新髓鞘质的能力不一样了。 如果正确训练自己的技能回路，即在精深练习时，努力完成那些勉强可以完成的事情，技能回路也会越来越敏捷和准确。 技能的通用理论： 精神练习X一万小时=世界级内容 3. 天降人才 优秀是一种习惯。——亚里士多德 4. 三大秘技秘技第一式：组快化 分成三步： 第一步，技能学习者整体了解一项任务——一个大组快，巨大的回路。 第二步，尽可能把它分解成最基础的组快。 第三步，花时间用慢动作练习，再加速，以了解其内在的结构。 说明： 整体吸收：指花时间观察或倾听你所想的技能，比如一首曲子、一个动作，而且这项技能是以连贯的实体形式出现。这一过程基本上相当于在脑中把技能具体化。模仿是很有效的办法。重点是找到其中的技巧。 拆分组快 放慢练习：放慢练习会使你更加关注错误，每一次都提高了精确度——而对于髓鞘质的生长而言，精确就是一切。 秘技第二式：重复练习 “练习并不能使之完美：完美的练习才能使之完美。”髓鞘质为这句话添上了新的内涵。在训练技能方面你，没有什么比实地操练更有效。要在精深练习区练习，否则不管花费了多少时间效果都不会很显著。 秘技第三式：尝试体会 注意力、连接、建立、完整的、警觉、关注、错误、重复、疲劳、边缘、唤醒。 这是一个独特的清单。精深练习是有目标的奋斗：选定目标、努力争取、评估差距、回到初始步骤。髓鞘质的一个进化优势就是，它能够使任何回路绝缘化，甚至是那些一开始我们不喜欢的（可能开始不喜欢，但随着精深练习，髓鞘质的绝缘化，我们可能会享受这样的体验）。 第2章 激情5. 信号统治所有人的普遍原则： 才能需要精深练习； 精深练习需要充分的能量； 某些信号会触发巨大能量的迸发。 6. 疯狂的海岛 培养技能的关键是，树立信心。一旦信心点燃之后，它就能一直燃烧。 正确的语言可以作为信号，以让人维持着激情。 7. 点燃明灯 本节无笔记。 第3章 伯乐8. 伯乐的武器 仅仅看见两颗幼苗，就能知道哪一棵会长得个更高，这可能吗？唯一的答案是，判断谁优谁劣还为时尚早，他们都还在成长。 髓鞘质法则：讲解、示范、模仿、纠正、然后重复。 不要期望一下子取得大幅度的进步。试着每天进不一小点。这是必经之路，而一旦开始进步，就会持续前进。 伟大的教练更像艺术，而非科学。它存在于两个人之间的距离，存在于语言、姿势、表达中。 9. 伯乐的一万小时 如果你休息一天，实力就会倒退两天。 好老师关心学生的一言一行，而且通过这种关心，以及利用他们对该课题已有的深刻理解，他们能够捕捉到学生在技能学习道路上碰到的障碍，以及摸索过程中难以形容的状态，然后按照已经设定的目标与学生沟通。 教师的四大优势： 优势一：知识矩阵——伯乐的杀手锏 一位优秀的老师总是有能力引导学生更加深入，能够看到学生不断的深入，因为他可以从各个角度思考这件事情，而且可以推演出无穷无尽的点。换言之，那是一种神秘的混合物，包含了技术上的知识、策略、经验。能够让他们信手拈来，判断理解学生的进度，接下来该朝着哪些地方努力。简言之，这个只是矩阵是一位伟大的教师的杀手锏。 优势二：洞察力——鹰的视力 “我不会对你们一视同仁，那样没有意义，因为你们每个人都不一样。全能的上帝有着无穷的智慧，没用一个模子造我们。谢天谢地，如果他这么做了，那世界该有多无聊啊？你不觉得吗？你们的身高、体重、背景、智力、才能等等都不一样。所以，你们每一位都应该区别对待，那是最适合你的。我会决定如何对待你们每一个人。” 优势三：简明的指示——神奇的教鞭 优势四：气质与诚信——不可阻挡的魅力 把学员推入髓鞘质生长，最终朝着每位教师都期盼的那一天前进：学生可以自己教自己。 10. 伯乐的赌注 教师就是为了逐步淡出。——托马斯卡拉瑟斯 第4章 后记：一万小时的世界 这个模型的好处是，它适用各种技能，各种情况，小至一个家庭，大至一个国家。 最后补充关于教育 学生需要伟大的老师。 早教光盘不会使孩子更聪明，反而会使他们变笨。因为它有效的阻止了精深练习的机会。光盘上的图像和声音有趣逼真，像是把婴儿泡在温水池里，但是与婴儿在真实生活中跌跌撞撞而获得的大量互动、犯错、学习比起来，则用处不大。 OK","tags":[]},{"title":"Markdown基础语法","date":"2017-04-23T13:56:58.000Z","path":"2017/04/23/Tool/001. Markdown基础语法/","text":"GO 本文转自献给写作者的 Markdown 新手指南 1. Markdown 的优点： 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 2. Markdown 的基础语法：2.1 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注意：“#”和[标题]之间建议保留一个字符的空格，这是标准的Markdown写法。 2.2 列表2.2.1 无序列表只需要在文字前面加上 - 就可以了。例如：123- 文本1- 文本2- 文本3 2.2.2 有序列表1231. 文本12. 文本23. 文本3 注意：“-”、“&gt;”与文本之间保留一个字符的空格。 2.3 链接和图片2.3.1 插入链接的语法：[显示文本](链接地址) 一个例子：[简书](http://www.jianshu.com) 2.3.2 插入图片的语法：![](图片链接地址) 一个例子：![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 注意：插入图片的语法和链接的语法很像，只是前面多了一个 ！ 2.4 引用在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了。 在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如： 1&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 注：”&gt;” 和文本之间要保留一个字符的空格。 2.5 粗体和斜体用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。例如：1*一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 其中「一盏灯」是斜体，「一简书」是粗体。 2.6 代码引用需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以将三个连续的`置于这段代码的首行和末行。 2.7 表格相关代码：12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 显示效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 相关代码：12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz 显示效果： dog bird cat foo foo foo bar bar bar baz baz baz 2.8 显示链接中带括号的图片代码如下：12![][1][1]: http://latex.codecogs.com/gif.latex?\\prod%20\\(n_&#123;i&#125;\\)+1 注意：像括号这种特殊符号需要用“\\”转义。 3. 结束语Markdown的基础语法就是这么多了，对于一个写作者来说，这些就完全够用了。 如果想要学习更多Markdown的用法，参考这一篇文章：『Markdown 语法说明』 OK","tags":[]}]